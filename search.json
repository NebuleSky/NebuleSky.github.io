[{"url":"/post/0.html","content":"# SpringBoot\n\n# 一、SpringBoot基础知识\n\n## 1.1 约定优于配置  \n\n> Build Anything with Spring Boot：Spring Boot is the starting point for   building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of   Spring.\n\n上面是引自官网的一段话，大概是说：  Spring Boot 是所有基于 Spring 开发的项目的起点。  Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。\n\n**约定优于配置**（ Convention over Conﬁguration ），又称按约定编程，是一种软件设计范式。\n本质上是说，系统、类库或框架应该假定合理的默认值，而非要求提供不必要的配置。比如说模型中有 一个名为User的类，那么数据库中对应的表就会默认命名为user。只有在偏离这一个约定的时候，例如 想要将该表命名为person ，才需要写有关这个名字的配置。\n比如平时架构师搭建项目就是限制软件开发随便写代码，制定出一套规范，让开发人员按统一的要求进 行开发编码测试之类的，这样就加强了开发效率与审查代码效率。所以说写代码的时候就需要按要求命 名，这样统一规范的代码就有良好的可读性与维护性了\n约定优于配置简单来理解，就是遵循约定\n\n\n\n## 1.2 SpringBoot概念                           \n\n### 1.2.1 spring优缺点分析\n\n**优点：**\nspring是Java企业版(Java Enterprise Edition，JEE ，也称J2EE)的轻量级代替品。无需开发重量级的    Enterprise JavaBean(EJB)，Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面 向切面编程，用简单 的Java对象(Plain Old Java Object，POJO)实现了EJB的功能\n\n**缺点：**\n虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始， Spring用XML配置，而且是很 多XML配 置。  Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML 配置。  Spring 3.0引入 了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。\n\n所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切  换，所以编 写配置挤占了编写应用程序逻辑的时间。和所有框架一样， Spring实用，但与此同时它要求 的回报也不少。\n\n除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标， 而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题 就会严重阻碍项目的开发进度\n\n\n\n### 1.2.2 SpringBoot解决上述spring问题\n\nSpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在 配置与逻辑 业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的 效率，一定程度上缩短 了项目周期\n\n**起步依赖**\n起步依赖本质上是一个Maven项目对象模型(Project Object Model，POM) ，定义了对其他库的传递依 赖，这些东西加在一起即支持某项功能。\n简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\n\n**自动配置**\nspringboot的自动配置，指的是springboot ，会自动将一些配置类的bean注册进ioc容器，我们可以需 要的地方使用@autowired或者@resource等注解来使用它。\n“自动”的表现形式就是我们只需要引我们想用功能的包，相关的配置我们完全不用管， springboot会自 动注入这些配置bean ，我们直接使用这些bean即可\nspringboot: 简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率\n\n\n\n## 1.3 SpringBoot 案例实现                                                               \n\n> 案例需求：请求Controller中的方法，并将返回值响应到页面\n\n**（ 1 ）使用Spring Initializr方式构建Spring Boot项目**\n本质上说， Spring Initializr是一个Web应用，它提供了一个基本的项目结构，能够帮助我们快速 构建一个基础的Spring Boot项目\n\n![image-20211226122458831](http://img.itzhameng.com/blog/image-20211226122458831.png?imageslim)\n\nProjectSDK”用于设置创建项目使用的JDK版本，这里，使用之前初始化设置好的JDK版本即可；\n在“Choose Initializr Service URL （选择初始化服务地址） ”下使用默认的初始化服务地址“https://start.spring.io”进行Spring Boot项目创建（注意使用快速方式创建Spring Boot项目时，所在主机须在联网状态下）\n\n![image-20211226122811626](http://img.itzhameng.com/blog/image-20211226122811626.png?imageslim)\n\n![image-20211226123021028](http://img.itzhameng.com/blog/image-20211226123021028.png?imageslim)\n\n\n\nSpring Boot项目就创建好了。创建好的Spring Boot项目结构如图：\n\n![image-20211226123627968](http://img.itzhameng.com/blog/image-20211226123627968.png?imageslim)\n\n使用Spring Initializr方式构建的SpringBoot项目会默认生成项目启动类、存放前端静态资源和页 面的文件夹、编写项目配置的配置文件以及进行项目单元测试的测试类\n\n\n\n**（2） 创建一个用于Web访问的Controller**\n\n`com.hzit.springboot_demo`包下创建名称为`controller`的包，在该包下创建一个请求处理控制类`HelloController `， 并编写一个请求处理方法（注意：`SpringbootDemoApplication.java`主程序需要和`controller`包，处在同一层级）\n\n![image-20211226124251132](http://img.itzhameng.com/blog/image-20211226124251132.png?imageslim)\n\n\n\n**`HelloController`具体内容如下：**\n\n``` java\n@RestController // 该注解为组合注解，等同于Spring中@Controller+@ResponseBody注解\npublic class HelloController {\n    @RequestMapping(\"/hello\")\n    public String demo() {\n        return \"你好 spring Boot\";\n    }\n}\n```\n\n\n\n**(3) 运行项目**\n运行主程序启动类SpringbootDemoApplication ，项目启动成功后，在控制台上会发现Spring Boot项目默认启动的端口号为8080 ，此时，可以在浏览器上访问“http://localhost:8080/hello”\n\n![image-20211226124505902](http://img.itzhameng.com/blog/image-20211226124505902.png?imageslim)\n\n\n\n项目运行结果：页面输出的内容是“你好Spring Boot”，至此，构建Spring Boot项目就完成了\n\n![image-20211226124632465](http://img.itzhameng.com/blog/image-20211226124632465.png?imageslim)\n\n附：如果出现乱码，尝试一下解决方案\n\n> 方案一：\n>\n> ``` java\n> @RequestMapping(produces = \"application/json; charset=utf-8\")\n> ```\n>\n> 方案二：\n>\n> ``` properties\n> #设置响应为utf-8\n> spring.http.encoding.force-response=true\n> ```\n\n\n\n## 1.4 单元测试与热部署\n\n###  1.4.1 单元测试\n\n开发中，每当完成一个功能接口或业务方法的编写后，通常都会借助单元测试验证该功能是否正  确。  Spring Boot对项目的单元测试提供了很好的支持，在使用时，需要提前在项目的pom.xml文件中添加`spring-boot-starter-test`测试依赖启动器，可以通过相关注解实现单元测试\n演示：\n**1 ．添加spring-boot-starter-test测试依赖启动器**\n在项目的pom.xml文件中添加spring-boot-starter-test测试依赖启动器，示例代码如下 ：\n\n``` xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n注意：使用Spring Initializr方式搭建的Spring Boot项目，会自动加入spring-boot-starter-test测试依赖 启动器，无需再手动添加\n\n**2 ．编写单元测试类和测试方法**\n使用Spring Initializr方式搭建的Spring Boot项目，会在src.test.java测试目录下自动创建与项目主程序 启动类对应的单元测试类\n\n``` java\n@RunWith(SpringRunner.class)\n// 测试启动器，并加载Spring Boot测试注解\n@SpringBootTest\n// 标记为Spring Boot单元测试类，并加载项目的ApplicationContext上下文环境\nclass SpringbootDemoApplicationTests {\n\n    @Autowired\n    private HelloController demoController;\n\n    // 自动创建的单元测试方法实例\n    @Test\n    void contextLoads() {\n        String demo = demoController.demo();\n        System.out.println(demo);\n    }\n\n}\n```\n\n上述代码中，先使用@Autowired注解注入了HelloController实例对象，然后在contextLoads() 方法中调用了HelloController类中对应的请求控制方法demo() ，并输出打印结果\n\n![image-20211226125420592](http://img.itzhameng.com/blog/image-20211226125420592.png?imageslim)\n\n\n\n### 1.4.2 热部署(可选)\n\n在开发过程中，通常会对一段业务代码不断地修改测试，在修改之后往往需要重启服务，有些服 务需要加载很久才能启动成功，这种不必要的重复操作极大的降低了程序开发效率。为此，SpringBoot框架专门提供了进行热部署的依赖启动器，用于进行项目热部署。\n<mark>无需手动重启项目，但是修改以后项目还是会自动重启项目</mark>\n演示：\n**1.添加spring-boot-devtools热部署依赖启动器**\n在Spring Boot项目进行热部署测试之前，需要先在项目的pom.xml文件中添加spring-boot-devtools热\n部署依赖启动器:\n\n``` xml\n<!-- 引入热部署依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n</dependency>\n```\n\n由于使用的是IDEA开发工具，添加热部署依赖后可能没有任何效果，接下来还需要针对IDEA开发 工具进行热部署相关的功能设置\n\n**2.IDEA工具热部署设置**\n选择IDEA工具界面的【File】->【Settings】选项，打开Compiler面板设置页面\n\n![image-20211226125909928](http://img.itzhameng.com/blog/image-20211226125909928.png?imageslim)\n\n选择Build下的Compiler选项，在右侧勾选“Build project automatically”选项将项目设置为自动编 译，单击【Apply】→【OK】按钮保存设置\n\n在项目任意页面中使用组合快捷键`Ctrl+Shift+Alt+/`打开Maintenance选项框，选中并打开 Registry页面，具体如图1-17所示\n\n![image-20211226130032724](http://img.itzhameng.com/blog/image-20211226130032724.png?imageslim)\n\n列表中找到`compiler.automake.allow.when.app.running` ，将该选项后的Value值勾选，用于指 定IDEA工具在程序运行过程中自动编译，最后单击【Close】按钮完成设置\n\n\n\n**3 ．热部署效果测试**\n\n页面原始输出的内容是“你好 spring Boot”。\n\n为了测试配置的热部署是否有效，接下来，在不关闭当前项目的情况下，将HelloController类中的请 求处理方法demo()的返回值修改为“你好 spring Boot，你好 Java”并保存，查看控制台信息会发现项目能够自动构 建和编译，说明项目热部署生效\n\n![image-20211226130522544](http://img.itzhameng.com/blog/image-20211226130522544.png?imageslim)\n\n可以看出，浏览器输出了“你好 spring Boot，你好 Java” ，说明项目热部署配置成功\n\n![image-20211226130533170](http://img.itzhameng.com/blog/image-20211226130533170.png?imageslim)\n\n## 1.5 全局配置文件\n\n官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties\n\n全局配置文件能够对一些默认配置值进行修改。  Spring Boot使用一个application.properties或者 application.yaml的文件作为全局配置文件，该文件存放在src/main/resource目录或者类路径 的/conﬁg ，一般会选择resource目录。接下来，将针对这两种全局配置文件进行讲解 ：\n\n### 1.5.1 application.properties配置文件                                                               \n\n使用Spring Initializr方式构建Spring Boot项目时，会在resource目录下自动生成一个空的 `application.properties`文件,\nSpring Boot项目启动时会自动加载application.properties文件。\n我们可以在application.properties文件中定义SpringBoot项目的相关属性，当然，这些相关属性可以 是系统属性、环境变量、命令参数等信息，也可以是自定义配置文件名称和位置\n\n``` properties\nserver.port=8081\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nserver.servlet.context-path=/boot\n```\n\n接下来，通过一个案例对Spring Boot项目中application.properties配置文件的具体使用进行讲解 演示：\n预先准备了两个实体类文件，后续会演示将application.properties配置文件中的自定义配置属性注入 到Person实体类的对应属性中\n\n**（ 1 ）先在项目的`com.hzit.springboot_demo`包下创建一个pojo包，并在该包下创建两个实体类Pet和Person**\n\n``` java\npublic class Pet {\n    private String type;\n    private String name;\n    \n    // 省略属性getXX()和setXX()方法\n    // 省略toString()方法\n}\n```\n\n``` java\n@Component   //用于将Person类作为Bean注入到Spring容器中\n@ConfigurationProperties(prefix = \"person\") //将配置文件中以person开头的属性注入到该 类中\npublic class Person {\n\n    private int id; //id\n    private String name;//名称\n    private List hobby; //爱好\n\n    private String[] family; //家庭成员\n    private Map map;\n    private Pet pet;    //宠物\n\n    // 省略属性getXX()和setXX()方法\n    // 省略toString()方法\n}\n```\n\n@ConﬁgurationProperties(preﬁx = \"person\")注解的作用是将配置文件中以<font color='red'>person开头</font>的属性值通过 setXX()注入到实体类对应属性中\n@Component注解的作用是将当前注入属性值的Person类对象作为Bean组件放到Spring容器中，只有 这样才能被@ConﬁgurationProperties注解进行赋值\n\n**（ 2）打开项目的resources目录下的application.properties配置文件，在该配置文件中编写需要对 Person类设置的配置属性**\n\n``` properties\nperson.id=1001\nperson.name=翠花\nperson.hobby=吃饭,睡觉,打豆豆\nperson.family=张大毛,王老五\nperson.map.k1=v1\nperson.map.k2=v2\nperson.pet.type=dog\nperson.pet.name=来福\n```\n\n编写application.properties配置文件时，由于要配置的Person对象属性是我们自定义的， Spring Boot无法自动识别，所以不会有任何书写提示。在实际开发中，为了出现代码提示的效果来方便配置， 在使用@ConﬁgurationProperties注解进行配置文件属性值注入时，可以在pom.xml文件中添加一个  Spring Boot提供的配置处理器依赖:\n\n``` xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n在pom.xml中添加上述配置依赖后，还需要重新运行项目启动类或者使用“Ctrl+F9”快捷键（即Build Project）重构当前Spring Boot项目方可生效\n\n**（ 3 ）查看application.properties配置文件是否正确**\n\n同时查看属性配置效果，打开通过IDEA工具创建 的项目测试类，在该测试类中引入Person实体类Bean ，并进行输出测试\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class PropertiesTests {\n\n    @Autowired\n    private Person person;\n\n    @Test\n    public void test(){\n        System.out.println(\"person = \" + person);\n    }\n}\n```\n\n打印结果：\n\n![image-20211226135642436](http://img.itzhameng.com/blog/image-20211226135642436.png?imageslim)\n\n可以看出，测试方法test()运行成功，同时正确打印出了Person实体类对象。至此，说明 application.properties配置文件属性配置正确，并通过相关注解自动完成了属性注入\n\n\n\n### 1.5.2 application.yaml配置文件\n\n> YAML(YAML Ain't a Markup Language)不是一种标记语言的外语缩写  ；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。--百度百科\n\nYAML文件格式是Spring Boot支持的一种JSON超集文件格式，相较于传统的Properties配置文件，YAML文件以数据为核心，是一种更为直观且容易被电脑识别的数据序列化格式。  application.yaml配置 文件的工作原理和application.properties是一样的，只不过yaml格式配置文件看起来更简洁一些。\n\n- YAML文件的扩展名可以使用**.yml**或者**.yaml**。\n- application.yml文件使用 “key: （空格） value”格式配置属性，使用缩进控制层级关系。 \n\n这里，针对不同数据类型的属性值，介绍一下YAML\n**（ 1）value值为普通数据类型（例如数字、字符串、布尔等）**\n当YAML配置文件中配置的属性值为普通数据类型时，可以直接配置对应的属性值，同时对于字符 串类型的属性值，不需要额外添加引号，示例代码如下\n\n``` yaml\nserver:\n  port: 8001\n  servlet:\n    context-path: /hello\n```\n\n上述代码用于配置server的port和servlet属性属于一个级别，以上配置等价于properties文件中：\n\n``` properties\nserver.port=8001\nserver.servlet.context-path=/hello\n```\n\n\n\n**（ 2）value值为数组和单列集合**\n\n当YAML配置文件中配置的属性值为数组或单列集合类型时，主要有两种书写方式：**缩进式写法**和**行内式**写法。\n\n其中，缩进式写法还有两种表示形式，示例代码如下\n\n``` yaml\nperson:\n  hobby:\n    - play\n    - read\n    - sleep\n```\n\n或者\n\n``` yaml\nperson:\n  hobby:\n    play,\n    read,\n    sleep\n```\n\n上述代码中，在YAML配置文件中通过两种缩进式写法对person对象的单列集合（或数组）类型的爱好 hobby赋值为play、 read和sleep。其中一种形式为“- （空格）属性值” ，另一种形式为多个属性值之后 加英文逗号分隔（注意，最后一个属性值后不要加逗号）。\n\n``` yaml\nperson:\n  hobby: [play,read,sleep]\n```\n\n通过上述示例对比发现， YAML配置文件的行内式写法更加简明、方便。另外，包含属性值的中括 号“[]”还可以进一步省略，在进行属性赋值时，程序会自动匹配和校对\n\n\n\n**（ 3）value值为Map集合和对象**\n当YAML配置文件中配置的属性值为Map集合或对象类型时， YAML配置文件格式同样可以分为两种书写 方式：缩进式写法和行内式写法。其中，缩进式写法的示例代码如下\n\n``` yaml\nperson:\n  map:\n    k1: v1\n    k2: v2\n```\n\n对应的行内式写法示例代码如下\n\n``` yaml\nperson:\n  map: {k1: v1,k2: v2}\n```\n\n在YAML配置文件中，配置的属性值为Map集合或对象类型时，缩进式写法的形式按照YAML文件格式编\n写即可，而行内式写法的属性值要用大括号“{}”包含。\n\n\n\n接下来，在Properties配置文件演示案例基础上，通过配置application.yaml配置文件对Person对象进 行赋值，具体使用如下\n（ 1 ）在项目的resources目录下，新建一个application.yaml配置文件，在该配置文件中编写为Person\n类设置的配置属性\n\n``` yaml\nperson:\n  id: 1002\n  name: 张无忌\n  hobby: [吃饭，睡觉，打豆豆]\n  family: [赵敏,周芷若]\n  map: {k1: v1,k2: v2}\n  pet: {type: dog,name: 旺财}\n```\n\n![image-20211226141600420](http://img.itzhameng.com/blog/image-20211226141600420.png?imageslim)\n\n可以看出，测试方法conﬁgurationTest()同样运行成功，并正确打印出了Person实体类对象。\n需要说明的是，本次使用application.yaml配置文件进行测试时需要提前将application.properties配置 文件中编写的配置注释，这是因为<mark>application.properties配置文件会覆盖application.yaml配置文件</mark>\n\n\n\n## 1.6 配置文件属性值的注入                                                              \n\n使用Spring Boot全局配置文件设置属性时：\n如果配置属性是Spring Boot已有属性，例如服务端口server.port ，那么Spring Boot内部会自动扫描并 读取这些配置文件中的属性值并覆盖默认属性。\n如果配置的属性是用户自定义属性，例如刚刚自定义的Person实体类属性，还必须在程序中注入这些配 置属性方可生效。\nSpring Boot支持多种注入配置文件属性的方式，下面来介绍如何使用注解@ConﬁgurationProperties 和@Value注入属性\n\n### 1.6.1 @ConﬁgurationProperties注入属性\n\nSpring Boot提供的@ConﬁgurationProperties注解用来快速、方便地将配置文件中的自定义属性值批 量注入到某个Bean对象的多个对应属性中。假设现在有一个配置文件，如果使用@ConﬁgurationProperties注入配置文件的属性，示例代码如下：\n\n``` java\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n    private int id;\n    // 属性的setXX()方法\n    public void setId(int id) {\n        this.id = id;\n    }\n}\n```\n\n上述代码使用@Component和@ConﬁgurationProperties(preﬁx = “person”)将配置文件中的每个属性 映射到person类组件中。\n需要注意的是，使用@ConﬁgurationProperties\n\n\n\n### 1.6.2 使用@Value注入属性\n\n@Value注解是Spring框架提供的，用来读取配置文件中的属性值并逐个注入到Bean对象的对应属性  中， Spring Boot框架从Spring框架中对@Value注解进行了默认继承，所以在Spring Boot框架中还可 以使用该注解读取和注入配置文件属性值。使用@Value注入属性的示例代码如下\n\n``` java\n@Component\npublic class Person {\n    @Value(\"${person.id}\")\n    private int id;\n}\n```\n\n上述代码中，使用@Component和@Value注入Person实体类的id属性。其中， @Value不仅可以将配置文件的属性注入Person的id属性，还可以直接给id属性赋值，这点是@ConﬁgurationProperties 不支持的\n\n**演示@Value注解读取并注入配置文件属性的使用:**\n\n**（ 1 ）在com.hzit.springboot_demo.pojo包下新创建一个实体类Student ，并使用@Value注解注入属性**\n\n``` java\n@Component\npublic class Student {\n    @Value(\"${person.id}\")\n    private int id;\n    @Value(\"${person.name}\")\n    private String name; //名称\n\n    //省略toString\n}\n```\n\nStudent类使用@Value注解将配置文件的属性值读取和注入。\n从上述示例代码可以看出，使用@Value注解方式需要对每一个属性注入设置，同时又免去了属性的setXX()方法\n\n**（ 2）再次打开测试类进行测试**\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class PropertiesTests {\n    @Autowired\n    public Student student;\n\n    @Test\n    public void test() {\n        System.out.println(\"student = \" + student);\n    }\n}\n```\n\n![image-20211226143002260](http://img.itzhameng.com/blog/image-20211226143002260.png?imageslim)\n\n可以看出，测试方法test()运行成功，同时正确打印出了Student实体类对象。需要说明的 是，本示例中只是使用@Value注解对实例中Student对象的普通类型属性进行了赋值演示\n\n而@Value   注解对于包含Map集合、对象以及YAML文件格式的行内式写法的配置文件的属性注入都不支持，如果  赋值会出现错误\n\n\n\n## 1.7 自定义配置                                                                                \n\nspring Boot免除了项目中大部分的手动配置，对于一些特定情况，我们可以通过修改全局配置文  件以适应具体生产环境，可以说，几乎所有的配置都可以写在application.peroperties文件中， Spring  Boot会自动加载全局配置文件从而免除我们手动加载的烦恼。\n但是，如果我们自定义配置文件， Spring Boot是无法识别这些配置文件的，此时就需要我们手动加载。接下来，将针对Spring Boot的自定义配   置文件及其加载方式进行讲解\n\n### 1.7.1 使用@PropertySource加载配置文件                                                          \n\n对于这种加载自定义配置文件的需求，可以使用@PropertySource注解结合@Conﬁguration注解  配置类的方式来实现。  @PropertySource注解用于指定自定义配置文件的具体位置和名称。同时，为了 保证Spring Boot能够扫描该注解，还需要类上添加@Conﬁguration注解将实体类作为自定义配置类。\n当然，如果需要将自定义配置文件中的属性值注入到对应类的属性中，可以使用\n@ConﬁgurationProperties或者@Value注解进行属性值注入\n演示：\n（ 1 ）打开Spring Boot项目的resources目录，在项目的类路径下新建一个test.properties自定义配 置文件，在该配置文件中编写需要设置的配置属性\n\n``` properties\n#对实体类对象MyProperties进行属性配置\ntest.id=110\ntest.name=test\n```\n\n（ 2）在`com.hzit.springboot_demo.pojo`包下新创建一个配置类MyProperties ，提供test.properties自定义配置文件中对应的属性，并根据@PropertySource注解的使用进行相关配置\n\n``` java\n@Configuration   // 自定义配置类\n@PropertySource(\"classpath:test.properties\")  // 指定自定义配置文件位置和名称\n@EnableConfigurationProperties(MyProperties.class) // 开启对应配置类的属性注入功 能\n@ConfigurationProperties(prefix = \"test\")     // 指定配置文件注入属性前缀\npublic class MyProperties {\n    private int id;\n    private String name;\n\n    // 省略属性getXX()和setXX()方法\n    // 省略toString()方法\n}\n```\n\n主要是一个自定义配置类，通过相关注解引入了自定义的配置文件，并完成了自定义属性值的注 入。示例中的几个注解，具体说明如下:\n\n- @Conﬁguration注解表示当前类是一个自定义配置类，并添加为Spring容器的组件，这里也可以使用传统的@Component注解；\n- @PropertySource(\"classpath:test.properties\")注解指定了自定义配置文件的位置和名称，此示例表示自定义配置文件为classpath类路径下的test.properties文件；\n- @ConﬁgurationProperties(preﬁx = \"test\")注解将上述自定义配置文件test.properties中以test开头的属性值注入到该配置类属性中。\t\n- 如果配置类上使用的是@Component注解而非@Conﬁguration注解，那么@EnableConﬁgurationProperties注解还可以省略\n\n\n\n（ 3 ）进行测试\n\n``` java\n@Autowired\nprivate MyProperties myProperties;\n@Test\npublic void myPropertiesTest() {\n    System.out.println(myProperties);\n}\n```\n\n![image-20211226152840959](http://img.itzhameng.com/blog/image-20211226152840959.png?imageslim)\n\n\n\n### 1.7.2 @Conﬁguration编写自定义配置类\n\n在Spring Boot框架中，推荐使用配置类的方式向容器中添加和配置组件\n在Spring Boot框架中，通常使用@Conﬁguration注解定义一个配置类， Spring Boot会自动扫描和识别 配置类，从而替换传统Spring框架中的XML配置文件。\n当定义一个配置类后，还需要在类中的方法上使用@Bean注解进行组件配置，将方法的返回对象注入到 Spring容器中，并且组件名称默认使用的是方法名，当然也可以使用@Bean注解的name或value属性    自定义组件的名称\n\n演示：\n（ 1 ）在项目下新建一个`com.hzit.springboot_demo.service`包，并在该包下新创建一个类MyService ，该类中不需要编写 任何代码\n\n``` java\npublic class MyService {\n}\n```\n\n创建了一个空的MyService类，而该类目前没有添加任何配置和注解，因此还无法正常被Spring Boot扫 描和识别\n\n（ 2） 在项目的`com.hzit.springboot_demo.config`包下，新建一个类MyConﬁg ，并使用@Conﬁguration注解将该类声 明一个配置类，内容如下：\n\n``` java\n@Configuration\npublic class MyConfig {\n    @Bean       // 将返回值对象作为组件添加到Spring容器中，该组件id默认为方法名\n    public MyService myService() {\n        return new MyService();\n    }\n}\n```\n\nMyConﬁg是@Conﬁguration注解声明的配置类（类似于声明了一个XML配置文件），该配置类会\n\n被Spring Boot自动扫描识别；使用@Bean注解的myService()方法，其返回值对象会作为组件添加到了 Spring容器中（类似于XML配置文件中的标签配置），并且该组件的id默认是方法名myService\n\n（ 3 ）测试类\n\n``` java\n@Autowired\nprivate ApplicationContext applicationContext;\n\n@Test\npublic void iocTest() {\n    MyService myService = applicationContext.getBean(MyService.class);\n    System.out.println(\"myService = \" + myService);\n    System.out.println(applicationContext.containsBean(\"myService\"));\n}\n```\n\n上述代码中，先通过@Autowired注解引入了Spring容器实例ApplicationContext ，然后在测试方法 iocTest()中测试查看该容器中是否包括id为myService的组件。\n\n执行测试方法iocTest() ，查看控制台输出效果，结果如下：\n\n![image-20211226153911377](http://img.itzhameng.com/blog/image-20211226153911377.png?imageslim)\n\n从测试结果可以看出，测试方法iocTest()运行成功，显示运行结果为true ，表示Spirng的IOC容器中也 已经包含了id为myService的实例对象组件，说明使用自定义配置类的形式完成了向Spring容器进行组 件的添加和配置\n\n\n\n## 1.8 随机数设置及参数间引用                         \n\n在Spring Boot配置文件中设置属性时，除了可以像前面示例中显示的配置属性值外，还可以使用 **随机值**和参数间引用对属性值进行设置。下面，针对配置文件中这两种属性值的设置方式进行讲解\n\n### 1.8.1随机值设置           \n\n在Spring Boot配置文件中，随机值设置使用到了Spring Boot内嵌的` RandomValuePropertySource`类，对一些隐秘属性值或者测试用例属性值进行随机值注入\n随机值设置的语法格式为${random.xx}，xx表示需要指定生成的随机数类型和范围，它可以生成\n随机的整数、  uuid或字符串，示例代码如下\n\n``` properties\n#配置随机值\nmy.secret=${random.value}\n\n# 配置随机整数\nmy.number=${random.int}\n\n# 配置随机long类型数\nmy.bignumber=${random.long}\n\n# 配置随机uuid类型数\nmy.uuid=${random.uuid}\n\n# 配置小于10的随机整数\nmy.number.less.than.ten=${random.int(10)}\n\n# 配置范围在[1024,65536]之间的随机整数 \nmy.number.in.range=${random.int[1024,65536]}\n```\n\n上述代码中，使用RandomValuePropertySource类中random提供的随机数类型，分别展示了不 同类型随机值的设置示例\n\n\n\n### 1.8.2参数间引用\n\n在Spring Boot配置文件中，配置文件的属性值还可以进行参数间的引用，也就是在后一个配置的 属性值中直接引用先前已经定义过的属性，这样可以直接解析其中的属性值了。\n使用参数间引用的好处就是，在多个具有相互关联的配置属性中，只需要对其中一处属性预先配置，其 他地方都可以引用，省去了后续多处修改的麻烦\n参数间引用的语法格式为${xx}，xx表示先前在配置文件中已经配置过的属性名，示例代码如下\n\n``` properties\napp.name=MyApp\napp.description=${app.name} is a Spring Boot application\n```\n\n上述参数间引用设置示例中，先设置了“app.name=MyApp” ，将app.name属性的属性值设置为了 MyApp ；接着，在app.description属性配置中，使用${app.name}对前一个属性值进行了引用\n接下来，通过一个案例来演示使用随机值设置以及参数间引用的方式进行属性设置的具体使用和 效果，具体步骤如下\n（ 1 ）打开Spring Boot项目resources目录下的application.properties配置文件，在该配置文件中 分别通过随机值设置和参数间引用来配置两个测试属性，示例代码如下\n\n``` properties\n# 随机值设置以及参数间引用配置\ntom.age=${random.int[10,20]}\ntom.description=tom的年龄可能是${tom.age}\n```\n\n在上述application.properties配置文件中，先使用随机值设置了tom.age属性的属性值，该属性 值设置在了[10,20]之间，随后使用参数间引用配置了tom.description属性\n\n（ 2）打开\\项目的测试类，在该测试类中新增字符串类型的description属性，并将配置文件中的 tom.description属性进行注入，然后新增一个测试方法进行输出测试，示例代码如下\n\n``` java\n@Value(\"${tom.description}\")\nprivate String description;\n\n@Test\npublic void placeholderTest() {\n    System.out.println(description);\n}\n```\n\n上述代码中，通过@Value(\"${tom.description}\")注解将配置文件中的tom.description属性值注入到了 对应的description属性中，在测试方法placeholderTest()中对该属性值进行了输出打印。\n\n执行测试方法placeholderTest() ，查看控制台输出效果\n\n![image-20211226155755564](http://img.itzhameng.com/blog/image-20211226155755564.png?imageslim)\n\n可以看出，测试方法placeholderTest()运行成功，并打印出了属性description的注入内容，该内  容与配置文件中配置的属性值保持一致。接着，重复执行测试方法placeholderTest() ，查看控制台输出 语句中显示的年龄就会在[10,20]之间随机显示\n\n\n\n# 二、SpringBoot原理深入及源码剖析\n\n传统的Spring框架实现一个Web服务，需要导入各种依赖JAR包，然后编写对应的XML配置文件   等，相较而言， Spring Boot显得更加方便、快捷和高效。那么， Spring Boot究竟如何做到这些的呢？\n接下来分别针对Spring Boot框架的依赖管理、自动配置和执行流程进行深入分析\n\n## 2.1 依赖管理\n\n> 问题：（ 1 ）为什么导入dependency时不需要指定版本？\n\n在Spring Boot入门程序中，项目pom.xml文件有两个核心依赖，分别是spring-boot-starter- parent和spring-boot-starter-web ，关于这两个依赖的相关介绍具体如下：\n\n### 2.1.1 spring-boot-starter-parent依赖\n\n在springboot_demo项目中的pom.xml文件中找到spring-boot-starter-parent依赖，示例代码如下:\n\n``` xml\n<!-- Spring Boot父项目依赖管理 -->\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.6.2</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n```\n\n上述代码中，将spring-boot-starter-parent依赖作为Spring Boot项目的统一父项目依赖管理，并\n将项目版本号统一为`2.6.2` ，该版本号根据实际开发需求是可以修改的\n使用“Ctrl+鼠标左键”进入并查看spring-boot-starter-parent底层源文件，发现spring-boot- starter-parent的底层有一个父依赖spring-boot-dependencies ，核心代码具体如下\n\n``` xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.6.2</version>\n    </parent>\n```\n\n继续查看spring-boot-dependencies底层源文件，核心代码具体如下：\n\n``` xml\n<properties>\n    <activemq.version>5.16.3</activemq.version>\n    <mysql.version>8.0.27</mysql.version>\n    <spring-amqp.version>2.4.1</spring-amqp.version>\n    <spring-batch.version>4.3.4</spring-batch.version>\n    <tomcat.version>9.0.56</tomcat.version>\n    <antlr2.version>2.7.7</antlr2.version>\n    <appengine-sdk.version>1.9.93</appengine-sdk.version>\n    <artemis.version>2.19.0</artemis.version>\n    <aspectj.version>1.9.7</aspectj.version>\n    <assertj.version>3.21.0</assertj.version>\n    <atomikos.version>4.0.6</atomikos.version>\n    <awaitility.version>4.1.1</awaitility.version>\n    <build-helper-maven-plugin.version>3.2.0</build-helper-maven-plugin.version>\n    <byte-buddy.version>1.11.22</byte-buddy.version>\n    <caffeine.version>2.9.3</caffeine.version>\n    <cassandra-driver.version>4.13.0</cassandra-driver.version>\n    <classmate.version>1.5.1</classmate.version>\n    <!-- .... -->\n</properties>\n```\n\n从spring-boot-dependencies底层源文件可以看出，该文件通过标签对一些常用技术框架的依赖文件 进行了统一版本号管理，例如activemq、 spring、tomcat等，都有与Spring Boot 2.6.2版本相匹配的  版本，这也是pom.xml引入依赖文件不需要标注依赖文件版本号的原因。\n需要说明的是，如果pom.xml引入的依赖文件不是 spring-boot-starter-parent管理的，那么在 pom.xml引入依赖文件时，需要使用标签指定依赖文件的版本号。\n\n\n\n> 问题2： spring-boot-starter-parent父依赖启动器的主要作用是进行版本统一管理，那么项目运 行依赖的JAR包是从何而来的？\n\n### 2.1.2 spring-boot-starter-web依赖\n\n查看spring-boot-starter-web依赖文件源码，核心代码具体如下\n\n``` xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n        <version>2.6.2</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-json</artifactId>\n        <version>2.6.2</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-tomcat</artifactId>\n        <version>2.6.2</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-web</artifactId>\n        <version>5.3.14</version>\n        <scope>compile</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.3.14</version>\n        <scope>compile</scope>\n    </dependency>\n</dependencies>\n```\n\n从上述代码可以发现， spring-boot-starter-web依赖启动器的主要作用是提供Web开发场景所需的底层 所有依赖\n正是如此，在pom.xml中引入spring-boot-starter-web依赖启动器时，就可以实现Web场景开发，而 不需要额外导入Tomcat服务器以及其他Web依赖文件等。当然，这些引入的依赖文件的版本号还是由 spring-boot-starter-parent父依赖进行的统一管理。\n\nSpring Boot除了提供有上述介绍的Web依赖启动器外，还提供了其他许多开发场景的相关依赖， 我们可以打开Spring Boot官方文档，搜索“Starters”关键字查询场景依赖启动器\n\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters\n\n![image-20211226162004268](http://img.itzhameng.com/blog/image-20211226162004268.png?imageslim)\n\n\n\n列出了Spring Boot官方提供的部分场景依赖启动器，这些依赖启动器适用于不同的场景开发，使用时 只需要在pox.xml文件中导入对应的依赖启动器即可。\n需要说明的是， Spring Boot官方并不是针对所有场景开发的技术框架都提供了场景启动器，例如数据   库操作框架MyBatis、阿里巴巴的Druid数据源等， Spring Boot官方就没有提供对应的依赖启动器。为  了充分利用Spring Boot框架的优势，在Spring Boot官方没有整合这些技术框架的情况下， MyBatis、  Druid等技术框架所在的开发团队主动与Spring Boot框架进行了整合，实现了各自的依赖启动器，例如 mybatis-spring-boot-starter、 druid-spring-boot-starter等。我们在pom.xml文件中引入这些第三方  的依赖启动器时，切记要配置对应的版本号\n\n\n\n## 2.2 自动配置（启动流程）                                                                \n\n概念：能够在我们添加jar包依赖的时候，自动为我们配置一些组件的相关配置，我们无需配置或者只需 要少量配置就能运行编写的项目\n问题： Spring Boot到底是如何进行自动配置的，都把哪些组件进行了自动配置？\n\nSpring Boot应用的启动入口是`@SpringBootApplication`注解标注类中的main()方法，\n@SpringBootApplication能够扫描Spring组件并自动配置Spring Boot\n下面，查看@SpringBootApplication内部源码进行分析  ，核心代码具体如下\n\n``` java\n//启动类\n@SpringBootApplication\npublic class SpringbootDemoApplication {\n\npublic static void main(String[] args) {\nSpringApplication.run(SpringbootDemoApplication.class, args); }\n}\n```\n\n\n\n``` java\n@Target(ElementType.TYPE) //注解的适用范围 ,Type表示注解可以描述在类、接口、注解或枚举\n@Retention(RetentionPolicy.RUNTIME) //表示注解的生命周期，Runtime运行时,反射可以获取\n@Documented //表示注解可以记录在javadoc中\n@Inherited //表示可以被子类继承该注解\n\n@SpringBootConfiguration // 标明该类为配置类\n@EnableAutoConfiguration // 启动自动配置功能 \n\n// 包扫描器\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\t//...\n}\n```\n\n从上述源码可以看出， @SpringBootApplication注解是一个组合注解，前面 4 个是注解的元数据 信息，  \n我们主要看后面 3 个注解： \n\n- @SpringBootConﬁguration\n- @EnableAutoConﬁguration\n\n- @ComponentScan\n\n关于这三个核心注解的相关说明具体如下：\n\n\n\n### **2.2.1@SpringBootConﬁguration注解**\n\n@SpringBootConﬁguration注解表示Spring Boot配置类。查看@SpringBootConﬁguration注解源 码，核心代码具体如下。\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration //配置IOC容器\npublic @interface SpringBootConfiguration {\n}\n```\n\n从上述源码可以看出， @SpringBootConﬁguration注解内部有一个核心注解@Conﬁguration ，该 注解是Spring框架提供的，表示当前类为一个配置类（ XML配置文件的注解表现形式），并可以被组件 扫描器扫描。由此可见， @SpringBootConﬁguration注解的作用与@Conﬁguration注解相同，都是标  识一个可以被组件扫描器扫描的配置类，只不过@SpringBootConﬁguration是被Spring Boot进行了重 新封装命名而已\n\n\n\n### 2.2.2@EnableAutoConﬁguration注解\n\n@EnableAutoConﬁguration注解表示开启自动配置功能，该注解是Spring Boot框架最重要的注 解，也是实现自动化配置的注解。同样，查看该注解内部查看源码信息，核心代码具体如下\n\n``` java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage //自动配置包\n@Import(AutoConfigurationImportSelector.class) //自动配置类扫描导入\npublic @interface EnableAutoConfiguration {\n}\n```\n\n可以发现它是一个组合注解， Spring 中有很多以Enable开头的注解，其作用就是借助@Import来 收集并注册特定场景相关的bean \n并加载到IoC容器。  @EnableAutoConﬁguration就是借助@Import  来收集所有符合自动配置条件的bean定义，并加载到IoC容器。\n\n下面，对这两个核心注解分别讲解 :\n\n#### 1、@AutoConﬁgurationPackage注解\n\n查看@AutoConﬁgurationPackage注解内部源码信息，核心代码具体如下：\n\n``` java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {\n}\n```\n\n从上述源码可以看出， @AutoConﬁgurationPackage注解的功能是由@Import注解实现的，它是 spring框架的底层注解，它的作用就是给容器中导入某个组件类\n例如 @Import(AutoConﬁgurationPackages.Registrar.class) ，它就是将Registrar这个组件类导入到容器 中，可查看Registrar类中registerBeanDeﬁnitions方法，这个方法就是导入组件类的具体实现 :\n\n![image-20211226164300417](http://img.itzhameng.com/blog/image-20211226164300417.png?imageslim)\n\n![image-20211226164335666](http://img.itzhameng.com/blog/image-20211226164335666.png?imageslim)\n\n从上述源码可以看出，在Registrar类中有一个registerBeanDeﬁnitions()方法，使用Debug模式启 动项目，  可以看到选中的部分就是`com.hzit.springboot_demo`。也就是说， @AutoConﬁgurationPackage注解的主要作 用就是将主程序类所在包及所有子包下的组件到扫描到spring容器中。\n因此 在定义项目包结构时，要求定义的包结构非常规范，项目主程序启动类要定义在最外层的根目录位 置，然后在根目录位置内部建立子包和类进行业务开发，这样才能够保证定义的类能够被组件扫描器扫描\n\n\n\n#### 2、@Import注解\n\n@Import({AutoConﬁgurationImportSelector.class})：将AutoConﬁgurationImportSelector这个类导入到spring容器中，                                                    AutoConﬁgurationImportSelector可以帮助springboot应用将所有符合条件的@Conﬁguration配置 都加载到当前SpringBoot创建并使用的IoC容器(ApplicationContext)中继续研究AutoConﬁgurationImportSelector这个类，\n通过源码分析这个类中是通过`getAutoConfigurationMetadata`这 个方法告诉springboot都需要导入那些组件：\n\n![image-20211226165218773](http://img.itzhameng.com/blog/image-20211226165218773.png?imageslim)\n\n**深入研究`loadMetadata`方法**\n\n``` java\nfinal class AutoConfigurationMetadataLoader {\n\n    //文件中为需要加载的配置类的类路径\n    protected static final String PATH = \"META-INF/spring-autoconfigure-metadata.properties\";\n\n    private AutoConfigurationMetadataLoader() {\n    }\n\n    static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) {\n        return loadMetadata(classLoader, PATH);\n    }\n\n    static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) {\n        try {\n            //spring-boot-autoconfigure-2.6.2.jar 中spring-autoconfigure-metadata.properties的信息生成URLS\n            Enumeration<URL> urls = (classLoader != null) ? classLoader.getResources(path)\n                : ClassLoader.getSystemResources(path);\n            Properties properties = new Properties();\n            \n            //解析URLS枚举对象中的信息封装成properties对象并加载\n            while (urls.hasMoreElements()) {\n                properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement())));\n            }\n            \n            //根据封装好的properties对象生成AutoConfigurationMetadata对象并返回\n            return loadMetadata(properties);\n        }\n        catch (IOException ex) {\n            throw new IllegalArgumentException(\"Unable to load @ConditionalOnClass location [\" + path + \"]\", ex);\n        }\n    }\n}\n\n```\n\n\n\n**深入研究`getCandidateConfigurations`方法：**\n\n![image-20211226171134168](http://img.itzhameng.com/blog/image-20211226171134168.png?imageslim)\n\n方法中有一个重要方法loadFactoryNames ，这个方法是让SpringFactoryLoader去加载一些组件的 名字。\n\n``` java\npublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n    ClassLoader classLoaderToUse = classLoader;\n    if (classLoader == null) {\n        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();\n    }\n\n    //获取出入的键\n    String factoryTypeName = factoryType.getName();\n    return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());\n}\n\nprivate static Map<String, List<String>> loadSpringFactories(ClassLoader classLoader) {\n    Map<String, List<String>> result = (Map)cache.get(classLoader);\n    if (result != null) {\n        return result;\n    } else {\n        HashMap result = new HashMap();\n\n        try {\n            //加载类路径下spring.factories文件，将其中设置 的配置类的全路径信息封装 为Enumeration类对象\n            Enumeration urls = classLoader.getResources(\"META-INF/spring.factories\");\n\n            //循环Enumeration类对象，根据相应的节点信息生成Properties对象，通过传入 的键获取值，在将值切割为一个个小的字符串转化为Array，方法result集合中\n            while(urls.hasMoreElements()) {\n                URL url = (URL)urls.nextElement();\n                UrlResource resource = new UrlResource(url);\n                Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                Iterator var6 = properties.entrySet().iterator();\n\n                while(var6.hasNext()) {\n                    Entry<?, ?> entry = (Entry)var6.next();\n                    String factoryTypeName = ((String)entry.getKey()).trim();\n                    String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                    String[] var10 = factoryImplementationNames;\n                    int var11 = factoryImplementationNames.length;\n\n                    for(int var12 = 0; var12 < var11; ++var12) {\n                        String factoryImplementationName = var10[var12];\n                        ((List)result.computeIfAbsent(factoryTypeName, (key) -> {\n                            return new ArrayList();\n                        })).add(factoryImplementationName.trim());\n                    }\n                }\n            }\n\n            result.replaceAll((factoryType, implementations) -> {\n                return (List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));\n            });\n            cache.put(classLoader, result);\n            return result;\n        } catch (IOException var14) {\n            throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var14);\n        }\n    }\n}\n\n```\n\n会去读取一个 `spring.factories `的文件，读取不到会出这个错误，我们继续根据会看到，最终路径的长 这样，而这个是spring提供的一个工具类\n\n``` java\npublic final class SpringFactoriesLoader {\n    public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n}\n```\n\n它其实是去加载一个外部的文件，而这文件是在\n\n![image-20211226172023713](http://img.itzhameng.com/blog/image-20211226172023713.png?imageslim)\n\n@EnableAutoConﬁguration就是从classpath中搜寻META-INF/spring.factories配置文件，并将其中 org.springframework.boot.autoconﬁgure.EnableutoConﬁguration对应的配置项通过反射（Java    Reﬂetion）实例化为对应的标注了@Conﬁguration的JavaConﬁg形式的配置类，并加载到IOC容器中\n以刚刚的项目为例，在项目中加入了Web环境依赖启动器，对应的WebMvcAutoConﬁguration自动配  置类就会生效，打开该自动配置类会发现，在该配置类中通过全注解配置类的方式对Spring MVC运行   所需环境进行了默认配置，包括默认前缀、默认后缀、视图解析器、  MVC校验器等。而这些自动配置类 的本质是传统Spring MVC框架中对应的XML配置文件，只不过在Spring Boot中以自动配置类的形式进  行了预先配置。因此，在Spring Boot项目中加入相关依赖启动器后，基本上不需要任何配置就可以运   行程序，当然，我们也可以对这些自动配置类中默认的配置进行更改\n\n**总结**\n因此springboot底层实现自动配置的步骤是：\n\n1. springboot应用启动；\n2. @SpringBootApplication起作用；\n3. @EnableAutoConﬁguration；\n4. @AutoConﬁgurationPackage ：这个组合注解主要是\n@Import(AutoConﬁgurationPackages.Registrar.class) ，它通过将Registrar类导入到容器中，而 Registrar类作用是扫描主配置类同级目录以及子包，并将相应的组件导入到springboot创建管理  的容器中；\n5. @Import(AutoConﬁgurationImportSelector.class) ：它通过将 AutoConﬁgurationImportSelector类导入到容器中， AutoConﬁgurationImportSelector类作用 是通过`getAutoConfigurationMetadata`方法执行的过程中，会使用内部工具类SpringFactoriesLoader ，查找        classpath上所有jar包中的META-INF/spring.factories进行加载，实现将配置类信息交给            SpringFactory加载器进行一系列的容器创建过程\n\n\n\n#### 3、@ComponentScan注解\n\n@ComponentScan注解具体扫描的包的根路径由Spring Boot项目主程序启动类所在包位置决 定，在扫描过程中由前面介绍的@AutoConﬁgurationPackage注解进行解析，从而得到Spring Boot项 目主程序启动类所在包的具体位置\n\n**总结：**\n\n@SpringBootApplication 的注解的功能就分析差不多了，  简单来说就是 3 个注解的组合注解：\n\n``` java\n|- @SpringBootConfiguration\n\t|- @Configuration  //通过javaConfig的方式来添加组件到IOC容器中\n|- @EnableAutoConfiguration\n\t|- @AutoConfigurationPackage //自动配置包，与@ComponentScan扫描到的添加到IOC \n    |- @Import(AutoConfigurationImportSelector.class) //到META-INF/spring.factories中定义的bean添加到IOC容器中\n|- @ComponentScan //包扫描\n```\n\n\n\n## 2.3  自定义Stater\n\n**SpringBoot starter机制**\nSpringBoot由众多Starter组成（一系列的自动化配置的starter插件）， SpringBoot之所以流行，也 是因为starter。\nstarter是SpringBoot非常重要的一部分，可以理解为一个可拔插式的插件，正是这些starter使得使用 某个功能的开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由Spring Boot自动通过     classpath路径下的类发现需要的Bean ，并织入相应的Bean。\n例如，你想使用Reids插件，那么可以使用spring-boot-starter-redis ；如果想使用MongoDB ，可以使 用spring-boot-starter-data-mongodb\n\n**为什么要自定义starter**\n开发过程中，经常会有一些独立于业务之外的配置模块。如果我们将这些可独立于业务代码之外的功能 配置模块封装成一个个starter，复用的时候只需要将其在pom中引用依赖即可， SpringBoot为我们完成自动装配\n\n**自定义starter的命名规则**\nSpringBoot提供的starter以 `spring-boot-starter-xxx `的方式命名的。官方建议自定义的starter使用 `xxx-spring-boot-starter `命名规则。以区分SpringBoot生态提供的starter\n\n\n\n**整个过程分为两部分：**\n\n​\t自定义starter\n\n​\t使用starter\n\n\n\n### 2.3.1 自定义starter\n\n#### 1、新建maven jar工程\n\n工程名为hzit-spring-boot-starter，导入依赖：\n\n``` xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-autoconfigure</artifactId>\n        <version>2.6.2</version>\n    </dependency>\n</dependencies>\n```\n\n\n\n#### 2、编写javaBean\n\n``` java\n@EnableConfigurationProperties(SimpleBean.class)\n@ConfigurationProperties(prefix = \"simplebean\")\npublic class SimpleBean {\n\n    private int id;\n    private String name;\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"SimpleBean{\" +\n            \"id=\" + id +\n            \", name='\" + name + '\\'' +\n            '}';\n    }\n}\n\n```\n\n\n\n#### 3、编写配置类MyAutoConﬁguration\n\n``` java\n@Configuration\n@ConditionalOnClass //@ConditionalOnClass：当类路径classpath下有指定的类的情况下进行 自动配置\npublic class MyAutoConfiguration {\n\n\n    static {\n        System.out.println(\"MyAutoConfiguration init....\");\n    }\n\n\n    @Bean\n    public SimpleBean simpleBean() {\n        SimpleBean simpleBean = new SimpleBean();\n        simpleBean.setId(1001);\n        simpleBean.setName(\"自动配置类....\");\n        return simpleBean;\n    }\n\n}\n```\n\n\n\n4、resources下创建/META-INF/spring.factories\n\n注意： META-INF是自己手动创建的目录， spring.factories也是手动创建的文件,在该文件中配置自己的 自动配置类\n\n``` properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.hzit.config.MyAutoConfiguration\n```\n\n![image-20211226185632156](http://img.itzhameng.com/blog/image-20211226185632156.png?imageslim)\n\n\n\n### 2.3.2 使用starter\n\n#### 1、导入自定义starter的依赖\n\n``` xml\n<dependency>\n    <groupId>com.hzit</groupId>\n    <artifactId>hzit-spring-boot-starter</artifactId>\n    <version>1.0-SNAPSHOT</version>\n</dependency>\n```\n\n\n\n#### 2、在全局配置文件中配置属性值\n\n``` properties\nsimplebean.id=1\nsimplebean.name=自定义starter\n```\n\n\n\n#### 3、编写测试方法\n\n``` java\n//测试自定义starter\n@Autowired\nprivate SimpleBean simpleBean;\n\n@Test\npublic void zdyStarterTest(){\n    System.out.println(simpleBean);\n}\n```\n\n\n\n## 2.4 执行原理   \n\n每个Spring Boot项目都有一个主程序启动类，在主程序启动类中有一个启动项目的main()方法，\n在该方法中通过执行SpringApplication.run()即可启动整个Spring Boot程序。\n问题：那么SpringApplication.run()方法到底是如何做到启动Spring Boot项目的呢？\n下面我们查看run()方法内部的源码，核心代码具体如下：\n\n``` java\n@SpringBootApplication\npublic class SpringbootDemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootDemoApplication.class, args);\n    }\n}\n```\n\n``` java\npublic static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {\n    return run(new Class[]{primarySource}, args);\n}\n\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n    return (new SpringApplication(primarySources)).run(args);\n}\n```\n\n从上述源码可以看出， SpringApplication.run()方法内部执行了两个操作，分别是     SpringApplication实例的初始化创建和调用run()启动项目，这两个阶段的实现具体说明如下\n\n### 2.4.1 SpringApplication实例的初始化创建\n\n查看SpringApplication实例对象初始化创建的源码信息，核心代码具体如下\n\n``` java\npublic SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {\n    this.sources = new LinkedHashSet();\n    this.bannerMode = Mode.CONSOLE;\n    this.logStartupInfo = true;\n    this.addCommandLineProperties = true;\n    this.addConversionService = true;\n    this.headless = true;\n    this.registerShutdownHook = true;\n    this.additionalProfiles = new HashSet();\n    this.isCustomEnvironment = false;\n    this.resourceLoader = resourceLoader;\n    Assert.notNull(primarySources, \"PrimarySources must not be null\");\n    //把项目启动类 .class设置为属性存储起来\n    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));\n\n    //判断当前webApplicationType应用的类型\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n\n    // 设置初始化器(Initializer),最后会调用这些初始化器\n    this.setInitializers(this.getSpringFactoriesInstances(\n        ApplicationContextInitializer.class));\n    // 设置监听器(Listener)\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    // 用于推断并设置项目main()方法启动的主程序启动类\n    this.mainApplicationClass = this.deduceMainApplicationClass();\n}\n```\n\n从上述源码可以看出， SpringApplication的初始化过程主要包括4部分，具体说明如下。\n（ 1）this.webApplicationType = WebApplicationType.deduceFromClasspath()\n用于判断当前webApplicationType应用的类型。  deduceFromClasspath()方法用于查看Classpath类路 径下是否存在某个特征类，从而判断当前webApplicationType类型是SERVLET应用（Spring 5之前的传 统MVC应用）还是REACTIVE应用（Spring 5开始出现的WebFlux交互式应用）\n（ 2）this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class))\n用于SpringApplication应用的初始化器设置。在初始化器设置过程中，会使用Spring类加载器             SpringFactoriesLoader从META-INF/spring.factories类路径下的META-INF下的spring.factores文件中 获取所有可用的应用初始化器类ApplicationContextInitializer。\n（ 3）this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class))\n用于SpringApplication应用的监听器设置。监听器设置的过程与上一步初始化器设置的过程基本一样，\n也是使用SpringFactoriesLoader从META-INF/spring.factories类路径下的META-INF下的\nspring.factores文件中获取所有可用的监听器类ApplicationListener。\n（4）this.mainApplicationClass = this.deduceMainApplicationClass() 用于推断并设置项目main()方法启动的主程序启动类\n\n\n\n### 2.4.2 项目的初始化启动\n\n分析完(new SpringApplication(primarySources)).run(args)源码前一部分SpringApplication实例 对象的初始化创建后，查看run(args)方法执行的项目初始化启动过程，核心代码具体如下：\n\n``` java\npublic ConfigurableApplicationContext run(String... args) {\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    Collection<SpringBootExceptionReporter> exceptionReporters = new\n        ArrayList();\n    this.configureHeadlessProperty();\n    // 第一步： 获取并启动监听器\n    SpringApplicationRunListeners listeners = this.getRunListeners(args); listeners.starting();\n    Collection exceptionReporters;\n    try {\n        ApplicationArguments applicationArguments =\n            new DefaultApplicationArguments(args);\n        // 第二步： 根据SpringApplicationRunListeners以及参数来准备环境\n        ConfigurableEnvironment environment =\n            this.prepareEnvironment(listeners, applicationArguments);\n        this.configureIgnoreBeanInfo(environment);\n        // 准备Banner打印器 - 就是启动Spring Boot的时候打印在console上的ASCII艺术字体\n        Banner printedBanner = this.printBanner(environment);\n\n        // 第三步： 创建Spring容器\n        context = this.createApplicationContext();\n        exceptionReporters =this.getSpringFactoriesInstances(SpringBootExceptionReporter.class,        new Class[]{ConfigurableApplicationContext.class}, new Object[]{context});\n        // 第四步： Spring容器前置处理\n        this.prepareContext(context, environment, listeners,\n                            applicationArguments, printedBanner);\n\n        // 第五步： 刷新容器\n        this.refreshContext(context);\n\n        // 第六步： Spring容器后置处理\n        this.afterRefresh(context, applicationArguments);\n        stopWatch.stop();\n        if(this.logStartupInfo) {\n            (new StartupInfoLogger(this.mainApplicationClass))\n            .logStarted(this.getApplicationLog(), stopWatch);\n        }\n        // 第七步： 发出结束执行的事件\n        listeners.started(context);\n\n        // 返回容器\n        this.callRunners(context, applicationArguments);\n    } catch (Throwable var10) {\n        this.handleRunFailure(context, var10, exceptionReporters, listeners); throw new IllegalStateException(var10);\n    }\n    try {\n        listeners.running(context);\n        return context;\n    } catch (Throwable var9) {\n        this.handleRunFailure(context, var9, exceptionReporters,\n                              (SpringApplicationRunListeners)null);\n        throw new IllegalStateException(var9);\n    }\n}\n```\n\n从上述源码可以看出，项目初始化启动过程大致包括以下部分：\n\n- 第一步：获取并启动监听器 \n\n> this.getRunListeners(args)和listeners.starting()方法主要用于获取SpringApplication实 例初始化过程中初始化的SpringApplicationRunListener监听器并运行。\n\n- 第二步：根据SpringApplicationRunListeners以及参数来准备环境\n\n> this.prepareEnvironment(listeners, applicationArguments)方法主要用于对项目运行环境进 行预设置，同时通过this.configureIgnoreBeanInfo(environment)方法排除一些不需要的运行环境\n\n- 第三步：创建Spring容器\n\n> 根据webApplicationType进行判断，   确定容器类型，如果该类型为SERVLET类型，会通过反射装载\n> 对应的字节码，也就是AnnotationConfigServletWebServerApplicationContext，接着使用之前 初始化设置的context（应用上下文环境） 、environment（项目运行环境） 、listeners（运行监听  器） 、applicationArguments（项目参数） 和printedBanner（项目图标信息） 进行应用上下文的组 装配置，并刷新配置\n\n- 第四步： Spring容器前置处理\n\n> 这一步主要是在容器刷新之前的准备动作。设置容器环境，包括各种变量等等，其中包含一个非常关键的操 作： 将启动类注入容器，为后续开启自动化配置奠定基础\n\n- 第五步：刷新容器\n\n> 开启刷新spring容器，通过refresh方法对整个IOC容器的初始化(包括bean资源的定位，解析，注册等 等)，同时向JVM运行时注册一个关机钩子，在JVM关机时会关闭这个上下文，除非当时它已经关闭\n\n- 第六步： Spring容器后置处理\n\n> 扩展接口，设计模式中的模板方法，默认为空实现。如果有自定义需求，可以重写该方法。比如打印一些启 动结束log，或者一些其它后置处理。\n\n-  第七步：发出结束执行的事件\n\n> 获取EventPublishingRunListener监听器，并执行其started方法，并且将创建的Spring容器传进去\n>\n> 了，创建一个ApplicationStartedEvent事件，并执行ConfigurableApplicationContext 的  publishEvent方法，也就是说这里是在Spring容器中发布事件，并不是在SpringApplication中发布 事件，和前面的starting是不同的，前面的starting是直接向SpringApplication中的监听器发布启 动事件。\n\n\n\n- 第八步：执行Runners\n\n> 用于调用项目中自定义的执行器XxxRunner类，使得在项目启动完成后立即执行一些特定程序。其中，    Spring Boot提供的执行器接口有ApplicationRunner 和CommandLineRunner两种，在使用时只需要 自定义一个执行器类实现其中一个接口并重写对应的run()方法接口，然后Spring Boot项目启动后会立  即执行这些特定程序\n\n下面，通过一个Spring Boot执行流程图，让大家更清晰的知道Spring Boot的整体执行流程和主要启 动阶段:\n\n![image-20211226190736899](http://img.itzhameng.com/blog/image-20211226190736899.png?imageslim)\n\n\n\n\n\n# 三、SpringBoot数据访问\n\n## 3.1 SpringBoot整合Mybatis\n\nMyBatis 是一款优秀的持久层框架， Spring Boot官方虽然没有对MyBatis进行整合，但是MyBatis 团队自行适配了对应的启动器，进一步简化了使用MyBatis进行数据的操作\n\n因为Spring Boot框架开发的便利性，所以实现Spring Boot与数据访问层框架（例如MyBatis）的 整合非常简单，主要是引入对应的依赖启动器，并进行数据库相关参数设置即可\n\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n\n\n数据库准备：\n\n``` sql\nCREATE TABLE `dept` (\n    `deptno` int(11) NOT NULL AUTO_INCREMENT COMMENT '部门编号',\n    `dname` varchar(20) NOT NULL COMMENT '部门名称',\n    `loc` varchar(30) NOT NULL COMMENT '部门地址',\n    PRIMARY KEY (`deptno`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```\n\n\n\n实体类\n\n``` java\npublic class Dept {\n    private int deptno;\n    private String dname;\n    private String loc;\n    //get set方法\n}\n```\n\n### 3.1.1 导入mybatis集成包\n\n``` xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.2</version>\n</dependency>\n```\n\n\n\n### 3.1.2 配置application.yml\n\n``` yaml\n#配置数据源   springboot2.x : 1)driver驱动类发生改变   2)url必须指定时区serverTimezone=Asia/Shanghai\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/bj2106?useUnicode=true&characterEncoding=UTF-8&useSSL=true&serverTimezone=Asia/Shanghai\n    username: root\n    password: root\n\n# mybatis相关的配置\nmybatis:\n  type-aliases-package: com.hzit.springboot_demo.pojo\n  mapper-locations: classpath*:mapper/*.xml\nlogging:\n  level:\n    com.hzit.springboot_demo.mapper: debug  # 打印sql语句\n```\n\n\n\n### 3.1.3 开启Mapper扫描\n\n``` java\n@SpringBootApplication\n@MapperScan(basePackages = {\"com.hzit.springboot_demo.mapper\"})  //在每个mapper添加@Mapper注解\npublic class SpringbootDemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootDemoApplication.class, args);\n    }\n}\n\n```\n\n\n\n也可以在对应的Mapper文件中使用@Mapper注解\n\n``` java\n@Mapper  // 如果main方法扫描@MapperScan 此处可以省略\npublic interface DeptMapper {\n    public Dept findDeptByKey(Long key);\n    public List<Dept> findList();\n}\n```\n\n\n\n### 3.1.4 创建xml配置文件\n\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.hzit.springboot_demo.mapper.DeptMapper\">\n    <select id=\"findDeptByKey\" parameterType=\"int\" resultType=\"com.hzit.springboot_demo.pojo.Dept\">\n        SELECT *\n        FROM dept\n        WHERE deptno = #{deptno}\n    </select>\n</mapper>\n```\n\n\n\n### 3.1.5 测试类\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class MybatisTests {\n    @Autowired\n    private DeptMapper deptMapper;\n\n    @Test\n    public void get() {\n        Dept dept = deptMapper.findDeptByKey(4);\n        System.out.println(\"dept = \" + dept);\n    }\n}\n```\n\n![image-20211226203920434](http://img.itzhameng.com/blog/image-20211226203920434.png?imageslim)\n\n\n\n## 3.2 SpringBoot整合MyBatis-Plus\n\n[MyBatis-Plus (opens new window)](https://github.com/baomidou/mybatis-plus)（简称 MP）是一个 [MyBatis (opens new window)](https://www.mybatis.org/mybatis-3/)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n官方文档：https://baomidou.com/\n\n此案例搭建在springboot已经整合mybatis的基础之上：\n\n\n\n### 3.2.1 导入包\n\n由于整合mybaits的时候，所需要的驱动包 已经导入，所以此处省略\n\n``` xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.4.3.4</version>\n</dependency>\n```\n\n\n\n### 3.2.2 修改实体类\n\n``` java\npublic class Dept {\n    @TableId(type = IdType.AUTO) //指定ID字段，并且使用自增的方式处理ID\n    private int deptno;\n    private String dname;\n    private String loc;\n}\n```\n\n\n\n### 3.2.3 编写mapper类\n\n``` java\npublic interface DeptMapper extends BaseMapper<Dept> {}\n```\n\nBaseMapper为MybatisPlus官方提供的maaper类，里面封装了大量的方法可以使用。详情参考帮助文档\n\nhttps://baomidou.com/pages/49cc81/#mapper-crud-%E6%8E%A5%E5%8F%A3\n\n![image-20211226205833555](http://img.itzhameng.com/blog/image-20211226205833555.png?imageslim)\n\n\n\n\n\n### 3.2.4 测试\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class MybaitsPlusTests {\n\n    @Autowired\n    private DeptMapper deptMapper;\n\n    @Test\n    public void get() {\n        Dept dept = deptMapper.selectById(4);\n        System.out.println(\"dept = \" + dept);\n    }\n}\n```\n\n\n\n### 3.2.5 小结\n\n通过以上几个简单的步骤，我们就实现了 Dept表的 CRUD 功能，甚至连 XML 文件都不用编写！\n\n从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。\n\n但 MyBatis-Plus 的强大远不止这些功能，想要详细了解 MyBatis-Plus 的强大功能？请查看官方帮助文档！\n\nhttps://baomidou.com/\n\n\n\n## 3.3 SpringBoot整合Redis\n\nSpring Boot 提供了对 Redis 集成的组件包`spring-boot-starter-data-redis`,可以直接开箱即用。\n\nSpring Boot 1.0 默认使用的是 Jedis 客户端，2.0 替换成 Lettuce，不过几乎感受不到差异，因为 `spring-boot-starter-data-redis` 为我们隔离了其中的差异性。\n\nLettuce 是一个可伸缩线程安全的 Redis 客户端，多个线程可以共享同一个 RedisConnection，它利用优秀 netty NIO 框架来高效地管理多个连接。\n\n![image-20201201152010340](http://img.itzhameng.com/blog/image-20201201152010340.png?imageslim)\n\n\n\n### 3.3.1 导入jar包\n\n``` xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n</dependency>\n```\n\n\n\n### 3.3.2 添加配置文件\n\n``` yaml\nspring:\n  redis:\n    host: 192.168.110.139   #Redis服务器地址\n    port: 6379              #Redis连接端口\n    password: 123           #Redis连接密码(默认为空)\n    database: 0             #Redis数据库索引(默认0)\n    lettuce:\n      pool:\n        max-active: 8       #连接池最大连接数（使用负值表示没有限制）\n        max-wait: -1        #连接池最大阻塞等待时间（使用负值表示没有限制）\n        max-idle: 8         #连接池中的最大空闲连接\n        min-idle: 0         #连接池中的最小空闲连接\n    timeout: 0              #连接超时时间（毫秒）\n```\n\n\n\n### 3.3.3 自定义模板类\n\n``` java\n@Configuration\npublic class RedisConfig {\n\n    /**\n     * 自定义RedisTemplate\n     * @param factory\n     * @return\n     */\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n\n        //创建模板类\n        RedisTemplate<String,Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(factory);\n\n        //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认JDK的序列化方式）\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n\n        //指定要序列化的域，fielad,get,set以及修饰的范围；ALL表示所有\n        //ANY：包含private,public等修饰符\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n\n        //设置类的全路径，但是不包含final修饰的类\n        //om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n\n        //设置key使用String序列化方式，value使用Jackson序列化方式\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n\n        redisTemplate.afterPropertiesSet();\n\n        return redisTemplate;\n    }\n}\n```\n\n\n\n\n\n### 3.3.4 RedisTemplate使用\n\nSpringBoot提供了两个固定好的模板类\n\n- RedisTemplate\t\t\t\t:操作对象\n- StringRedisTemplate     :操作字符串\n\n这两个模板类都提供了操作不同数据类型的方法：\n\n``` java\n @Autowired\n private RedisTemplate<String, Object> redisTemplate;\n\npublic String set(){\n\t//操作普通value\n    redisTemplate.opsForValue();\n    \n    //操作list\n    redisTemplate.opsForList();\n    \n    //操作set\n    redisTemplate.opsForSet();\n    \n    //操作zset\n    redisTemplate.opsForZSet();\n    \n    //操作hash\n    redisTemplate.opsForHash();\n}\n```\n\n\n\nStringRedisTemplate 继承了RedisTemplate，两者最大的区别就是序列化的方式不一致。\n\n``` java\npublic class StringRedisTemplate extends RedisTemplate<String, String> {\n    public StringRedisTemplate() {\n        this.setKeySerializer(RedisSerializer.string());\n        this.setValueSerializer(RedisSerializer.string());\n        this.setHashKeySerializer(RedisSerializer.string());\n        this.setHashValueSerializer(RedisSerializer.string());\n    }\n\n    public StringRedisTemplate(RedisConnectionFactory connectionFactory) {\n        this();\n        this.setConnectionFactory(connectionFactory);\n        this.afterPropertiesSet();\n    }\n\n    protected RedisConnection preProcessConnection(RedisConnection connection, boolean existingConnection) {\n        return new DefaultStringRedisConnection(connection);\n    }\n}\n```\n\n\n\n### 3.3.5 案例\n\n实体类:\n\n``` java\n@Data\n@Accessors(chain = true)\npublic class Person implements Serializable {\n\n    private Integer pid;\n    private String username;\n    private Integer age;\n\n}\n```\n\n\n\n测试:\n\n``` java\npackage com.itzhameng.learningredisdemo.controller;\n\nimport com.itzhameng.learningredisdemo.entities.Person;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.StringRedisTemplate;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\npublic class RedisController {\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @RequestMapping(\"/redis\")\n    public String set(){\n\n\n        redisTemplate.opsForValue().set(\"xxx\",\"hello world\");\n\n        Person person = new Person().setPid(1001).setUsername(\"小花\").setAge(20);\n        redisTemplate.opsForValue().set(\"yyy\",person);\n        return \"OK\";\n    }\n\n    @RequestMapping(\"/get\")\n    public Object get(){\n\n        Object person = redisTemplate.opsForValue().get(\"yyy\");\n        return person;\n    }\n\n    @RequestMapping(\"/redis2\")\n    public String set2(){\n\n\n        Person person1 = new Person().setPid(1001).setUsername(\"小花\").setAge(20);\n        Person person2 = new Person().setPid(1002).setUsername(\"小明\").setAge(20);\n        redisTemplate.opsForValue().set(\"mylist\", Arrays.asList(person1,person2));\n        return \"OK\";\n    }\n\n    @RequestMapping(\"/get2\")\n    public   List<Person> get2(){\n\n        List<Person> list = (List<Person>) redisTemplate.opsForValue().get(\"mylist\");\n        return list;\n    }\n\n    @RequestMapping(\"/redis3\")\n    public String set3(){\n\n\n        Person person1 = new Person().setPid(1001).setUsername(\"小花\").setAge(20);\n        Person person2 = new Person().setPid(1002).setUsername(\"小明\").setAge(20);\n        List<Person> list = Arrays.asList(person1, person2);\n        redisTemplate.opsForList().leftPushAll(\"mylist2\",list);\n        return \"OK\";\n    }\n\n    @RequestMapping(\"/get3\")\n    public List<Object> get3(){\n\n        List<Object> list = redisTemplate.opsForList().range(\"mylist2\",0,-1);\n        return list;\n    }\n\n    @RequestMapping(\"/redis4\")\n    public String set4(){\n\n        Map<String,Person> map = new HashMap<>();\n        Person person1 = new Person().setPid(1001).setUsername(\"小花\").setAge(20);\n        Person person2 = new Person().setPid(1002).setUsername(\"小明\").setAge(20);\n\n        map.put(\"p1\",person1);\n        map.put(\"p2\",person2);\n        redisTemplate.opsForHash().putAll(\"h1\",map);\n        return \"OK\";\n    }\n\n    @RequestMapping(\"/get4\")\n    public List<Object> get4(){\n        List<Object> list = redisTemplate.opsForList().range(\"mylist2\",0,-1);\n        return list;\n    }\n}\n```\n\n\n\n\n\n# 四、SpringBoot视图技术\n\n## 4.1 支持的视图技术 \n\n前端模板引擎技术的出现，使前端开发人员无需关注后端业务的具体实现，只关注自己页面的呈现效 果即可，并且解决了前端代码错综复杂的问题、实现了前后端分离开发。  Spring Boot框架对很多常用   的模板引擎技术（如： FreeMarker、Thymeleaf、 Mustache等）提供了整合支持\n\nSpring Boot不太支持常用的JSP模板，并且没有提供对应的整合配置，这是因为使用嵌入式 Servlet容器的Spring Boot应用程序对于JSP模板存在一些限制 ：\n\n- Spring Boot默认使用嵌入式Servlet容器以JAR包方式进行项目打包部署，这种JAR包方式不支持\n  JSP模板。\n- 如果使用Undertow嵌入式容器部署Spring Boot项目，也不支持JSP模板。\n- Spring Boot默认提供了一个处理请求路径“/error”的统一错误处理器，返回具体的异常信息。使用JSP模板时，无法对默认的错误处理器进行覆盖，只能根据Spring Boot要求在指定位置定制错误页 面。\n\n\n\n上面对Spring Boot支持的模板引擎进行了介绍，并指出了整合JSP模板的一些限制。接下来，对其 中常用的Thymeleaf模板引擎进行介绍，并完成与Spring Boot框架的整合实现\n\n## 4.2 静态资源映射规则\n\nResourceProperties.java\n指定了静态文件加载的位置及顺序:\n\n```xml\n\"classpath:/META‐INF/resources/\",\n\"classpath:/resources/\",\n\"classpath:/static/\",\n\"classpath:/public/\"\n\n\n\"/\"：当前项目的根路径\n```\n\n```java\n@ConfigurationProperties(\n    prefix = \"spring.resources\",\n    ignoreUnknownFields = false\n)\npublic class ResourceProperties implements ResourceLoaderAware {\n    private static final String[] SERVLET_RESOURCE_LOCATIONS = new String[]{\"/\"};\n    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"};\n```\n\nWebMvcAutoConfiguration.java\n\n```java\npublic class WebMvcAutoConfiguration {\n    public static final String DEFAULT_PREFIX = \"\";\n    public static final String DEFAULT_SUFFIX = \"\";\n\n//添加静态文件映射路径 \n public void addResourceHandlers(ResourceHandlerRegistry registry) {\n            if (!this.resourceProperties.isAddMappings()) {\n                logger.debug(\"Default resource handling disabled\");\n            } else {\n                Integer cachePeriod = this.resourceProperties.getCachePeriod();\n                if (!registry.hasMappingForPattern(\"/webjars/**\")) {\n                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{\"/webjars/**\"}).addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"}).setCachePeriod(cachePeriod));\n                }\n\n                String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n                if (!registry.hasMappingForPattern(staticPathPattern)) {\n                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(this.resourceProperties.getStaticLocations()).setCachePeriod(cachePeriod));\n                }\n\n            }\n        }\n```\n\n 所有 /webjars/** ，都会从** classpath:/META-INF/resources/webjars/** 找资源；![访问路径](https://upload-images.jianshu.io/upload_images/12555954-39c7b68458d2601f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## 4.3 webjars使用\n\n[官网:webjars.org](https://www.webjars.org/)\n作用:通过使用导入jar的形式来引用静态文件: 例如:\n\n```xml\n<!--引入jquery资源-->\n<dependency>\n\t<groupId>org.webjars</groupId>\n\t<artifactId>jquery</artifactId>\n\t<version>1.11.1</version>\n</dependency>\n```\n\n![导入之后的结果](https://upload-images.jianshu.io/upload_images/12555954-073aea47e191cf6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n此时访问路径为:http://localhost:8080/sb/webjars/jquery/1.11.1/jquery.js\n\n\n\n## 4.4 Thymeleaf \n\nThymeleaf是一种现代的基于服务器端的Java模板引擎技术，也是一个优秀的面向Java的XML、    XHTML、 HTML5页面模板，它具有丰富的标签语言、函数和表达式，在使用Spring Boot框架进行页面 设计时，一般会选择Thymeleaf模板\n\n官方文档：https://www.thymeleaf.org/\n\n\n\n### 4.4.1 Thymeleaf语法                                                                                                                    \n\n常用标签\n在HTML页面上使用Thymeleaf标签， Thymeleaf 标签能够动态地替换掉静态内容，使页面动态展示。\n为了大家更直观的认识Thymeleaf ，下面展示一个在HTML文件中嵌入了Thymeleaf的页面文件，示例\n代码如下：\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <link rel=\"stylesheet\" type=\"text/css\" media=\"all\"\n              href=\"../../css/gtvg.css\" th:href=\"@{/css/gtvg.css}\" /> <title>Title</title>\n    </head>\n    <body>\n        <p th:text=\"${hello}\">欢迎进入Thymeleaf的学习</p>\n    </body>\n</html>\n```\n\n上述代码中， “xmlns:th=\"http://www.thymeleaf.org\"“ 用于引入Thymeleaf模板引擎标签，使用   关键字“th”标注标签是Thymeleaf模板提供的标签，其中， “th:href”用于引入外联样式文件， “th:text”用 于动态显示标签文本内容。\n\n除此之外， Thymeleaf模板提供了很多标签，接下来，通过一张表罗列Thymeleaf的常用标签\n\n| th:标签    | 说明                                   |\n| ---------- | -------------------------------------- |\n| th:insert  | 布局标签，替换内容到引入的文件         |\n| th:replace | 页面片段包含（类似JSP中的include标签） |\n| th:each    | 元素遍历（类似JSP中的c:forEach标签）   |\n| th:if      | 条件判断，如果为真                     |\n| th:unless  | 条件判断，如果为假                     |\n| th:switch  | 条件判断，进行选择性匹配               |\n| th:case    | 条件判断，进行选择性匹配               |\n| th:value   | 属性值修改，指定标签属性值             |\n| th:href    | 用于设定链接地址                       |\n| th:src     | 用于设定链接地址                       |\n| th:text    | 用于指定标签显示的文本内容             |\n\n\n\n**标准表达式**\n\nThymeleaf模板引擎提供了多种标准表达式语法，在正式学习之前，先通过一张表来展示其主要语法 及说明\n\n| 说明           | 表达式语法 |\n| -------------- | ---------- |\n| 变量表达式     | ${...}     |\n| 选择变量表达式 | *{...}     |\n| 消息表达式     | #{...}     |\n| 链接URL表达式  | @{...}     |\n| 片段表达式     | ~{...}     |\n\n#### 1）变量表达式 ${...}\n\n变量表达式${...}主要用于获取上下文中的变量值，示例代码如下：\n\n``` html\n<p th:text=\"${title}\">这是标题</p>\n```\n\n示例使用了Thymeleaf模板的变量表达式${...}用来动态获取P标签中的内容，如果当前程序没有启动或  者当前上下文中不存在title变量，该片段会显示标签默认值“这是标题” ；如果当前上下文中存在title变量 并且程序已经启动，当前P标签中的默认文本内容将会被title变量的值所替换，从而达到模板引擎页面    数据动态替换的效果\n\n同时， Thymeleaf为变量所在域提供了一些内置对象，具体如下所示\n\n``` properties\n# ctx：上下文对象\n# vars：上下文变量\n# locale：上下文区域设置\n# request：（仅限Web Context）HttpServletRequest对象\n# response：（仅限Web Context）HttpServletResponse对象\n# session：（仅限Web Context）HttpSession对象\n# servletContext：（仅限Web Context）ServletContext对象\n```\n\n结合上述内置对象的说明，假设要在Thymeleaf模板引擎页面中动态获取当前国家信息，可以使用 #locale内置对象，示例代码如下\n\n``` html\nThe locale country is: <span th:text=\"${#locale.country}\">US</span>.\n```\n\n上述代码中，使用th:text=\"${#locale.country}\"动态获取当前用户所在国家信息，其中标签内默认 内容为US （美国），程序启动后通过浏览器查看当前页面时， Thymeleaf会通过浏览器语言设置来识别 当前用户所在国家信息，从而实现动态替换\n\n\n\n#### 2 ）选择变量表达式 *{...}\n\n选择变量表达式和变量表达式用法类似，一般用于从被选定对象而不是上下文中获取属性值，如 果没有选定对象，则和变量表达式一样，示例代码如下\n\n``` html\n<div th:object=\"${book}\">\n    <p>titile: <span th:text=\"*{title}\">标题</span>.</p>\n</div>\n```\n\n*{title} 选择变量表达式获取当前指定对象book的title属性值\n\n\n\n#### 3）消息表达式 #{...}\n\n消息表达式#{...}主要用于Thymeleaf模板页面国际化内容的动态替换和展示，使用消息表达式# {...}进行国际化设置时，还需要提供一些国际化配置文件。\n\n\n\n#### 4）链接表达式 @{...}\n\n链接表达式@{...}一般用于页面跳转或者资源的引入，在Web开发中占据着非常重要的地位，并且使用 也非常频繁，示例代码如下：\n\n``` html\n<a  th:href=\"@{http://localhost:8080/order/details(orderId=${o.id})}\">view</a> \n<a  th:href=\"@{/order/details(orderId=${o.id})}\">view</a>\n```\n\n上述代码中，链接表达式@{...}分别编写了绝对链接地址和相对链接地址。在有参表达式中，需要 按照@{路径(参数名称=参数值，参数名称=参数值...)}的形式编写，同时该参数的值可以使用变量表达式 来传递动态参数值\n\n\n\n#### 5）片段表达式 ~{...}\n\n片段表达式~{...}用来标记一个片段模板，并根据需要移动或传递给其他模板。其中，最常见的用法是使 用th:insert或th:replace属性插入片段，示例代码如下：\n\n``` html\n<div th:insert=\"~{thymeleafDemo::title}\"></div>\n```\n\n上述代码中，使用th:insert属性将title片段模板引用到该标签中  \n\nthymeleafDemo为模板名称，Thymeleaf会自动查找“/resources/templates/”目录下的 thymeleafDemo模板，title为片段名称\n\n\n\n### 4.4.2 基本使用\n\n常用的模板引擎:[jsp](http://www.runoob.com/jsp/jsp-tutorial.html),[freemarker](https://freemarker.apache.org/),[thymeleaf](https://www.thymeleaf.org/)等。springboot 官方推荐使用thymeleaf\n![模板引擎](https://upload-images.jianshu.io/upload_images/12555954-ef3c58e7ccbd3bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 1）Thymeleaf模板基本配置\n\n``` xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\nThymeleafProperties.java 设置模板的默认值\n\n``` java\n@ConfigurationProperties(\n    prefix = \"spring.thymeleaf\"\n)\npublic class ThymeleafProperties {\n    private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\");\n    private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\");\n    public static final String DEFAULT_PREFIX = \"classpath:/templates/\";\n    public static final String DEFAULT_SUFFIX = \".html\";\n    private boolean checkTemplate = true;\n    private boolean checkTemplateLocation = true;\n    private String prefix = \"classpath:/templates/\";\n    private String suffix = \".html\";\n    private String mode = \"HTML5\";\n}\n```\n\n模板默认的加载位置:`classpath:/templates/ *.html`文件\n\n\n\n#### 2）修改yaml配置\n\n``` yaml\nspring:\n  thymeleaf:\n    cache: false \n```\n\n修改为不缓存\n\n\n\n#### 3）引用命名空间\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n```\n\n\n\n#### 4）语法规则\n\n```html\n  <!--emp:集合的元素,itState:状态,需要遍历的值-->\n<tr th:each=\"emp,itState: ${empList}\">\n     <td><input type=\"checkbox\" name=\"checkbox_name\"> <span th:text=\"${itState.index+1}\"></span></td>\n     <td th:text=\"${emp.empno}\">1,001</td>\n     <td th:text=\"${emp.ename}\">Lorem</td>\n     <td th:text=\"${emp.job}\">ipsum</td>\n     <!--设置日期格式-->\n     <td th:text=\"${#dates.format(emp.hiredate,'yyyy-MM-dd')}\">dolor</td>\n     <td th:text=\"${emp.sal}\">sit</td>\n     <td th:text=\"${emp.dname}\">sit</td>\n     <td><a class=\"btn btn-sm btn-primary\" href=\"#\" th:href=\"@{'/emp/'+${emp.empno}}\"><span\n                        class=\"glyphicon glyphicon-edit\"></span>编辑</a>\n                  <!--重新定义一个属性:myhref，设置新的url路径-->\n         <a class=\"btn btn-sm btn-danger btn-del\" th:attr=\"myhref=@{'/emp/'+${emp.empno}}\" href=\"javascript:void(0)\" th:value=\"${emp.empno}\">\n                    <span class=\"glyphicon glyphicon-trash\"></span>删除</a></td>\n</tr>\n```\n\n具体语法参照：[thymeleaf帮助文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)\n\n\n\n"},{"title":"Maven配置流程","url":"/post/0.html","content":"\n介绍Maven的安装和配置\n<!-- more -->\n# Maven\n\n## maven安装和配置\n\n### 1.解压maven压缩包\n\n### 2.配置环境变量\n\n![image-20230625101908478](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251019652.png)\n\n![image-20230625101940744](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251019821.png)\n\n![image-20230625102252222](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251022350.png)\n\n![image-20230625102257751](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251022872.png)\n\n![image-20230625102401258](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251024347.png)\n\n![image-20230625102535200](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251025277.png)\n\n### 3.配置本地仓库\n\n![image-20230625102638665](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251026751.png)\n\n![image-20230625102953003](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251029053.png)\n\n![image-20230625103007555](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251030665.png)\n\n![image-20230625105654795](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251056899.png)\n\n## 在idea里面配置Maven：\n\n![image-20230625111006587](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251110730.png)\n\n![image-20230625111709243](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251117346.png)\n\n## 用idea创建java项目：\n\n![image-20230625113507993](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251135102.png)\n\n![image-20230625113727021](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251137101.png)\n\n## maven导入依赖\n\n### 1.在 pom.xml 中编写 <dependencies> 标签\n\n![image-20230625141728227](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251417330.png)\n\n### 2.在 <dependencies> 标签中使用 <dependency> 引入坐标定义坐标的 groupId，artifactId，version\n\n![image-20230625141804897](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251418957.png)\n\n### 3.点击刷新按钮，使坐标生效\n\n![image-20230625141835394](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251418485.png)","tags":["Mave"]},{"title":"demon","url":"/post/ae0842e5.html","content":"\n这是摘要\n<!-- more -->\n\n# 标题1\n## 标题2\n### 标题3\n#### 标题4\n##### 标题5\n\n**这里是加粗**\n\n*这里是斜体*\n\n~~这是横线~~\n\n*无序列表1\n*无序列表2\n\n1. 有序列表1\n2. 有序列表2\n\n`内嵌代码`\n\n```\n代码块\n```\n\n> 引用"}]