[{"title":"SpringBoot基础教程","url":"/post/c21a73e5.html","content":"\nSpring Boot 是一个基于 Spring 框架的快速开发应用程序的工具，它简化了 Spring 应用程序的配置和部署过程。本教程旨在为初学者提供关于 Spring Boot 的基础知识和使用指南。教程首先介绍了 Spring Boot 的概述，解释了它的设计原理和主要特点。它强调了 Spring Boot 的自动配置能力，以及如何利用 Starter 依赖简化项目的依赖管理。\n<!-- more -->\n\n# SpringBoot\n\n# 一、SpringBoot基础知识\n\n## 1.1 约定优于配置  \n\n> Build Anything with Spring Boot：Spring Boot is the starting point for   building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of   Spring.\n\n上面是引自官网的一段话，大概是说：  Spring Boot 是所有基于 Spring 开发的项目的起点。  Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。\n\n**约定优于配置**（ Convention over Conﬁguration ），又称按约定编程，是一种软件设计范式。\n本质上是说，系统、类库或框架应该假定合理的默认值，而非要求提供不必要的配置。比如说模型中有 一个名为User的类，那么数据库中对应的表就会默认命名为user。只有在偏离这一个约定的时候，例如 想要将该表命名为person ，才需要写有关这个名字的配置。\n比如平时架构师搭建项目就是限制软件开发随便写代码，制定出一套规范，让开发人员按统一的要求进 行开发编码测试之类的，这样就加强了开发效率与审查代码效率。所以说写代码的时候就需要按要求命 名，这样统一规范的代码就有良好的可读性与维护性了\n约定优于配置简单来理解，就是遵循约定\n\n\n\n## 1.2 SpringBoot概念                           \n\n### 1.2.1 spring优缺点分析\n\n**优点：**\nspring是Java企业版(Java Enterprise Edition，JEE ，也称J2EE)的轻量级代替品。无需开发重量级的    Enterprise JavaBean(EJB)，Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面 向切面编程，用简单 的Java对象(Plain Old Java Object，POJO)实现了EJB的功能\n\n**缺点：**\n虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始， Spring用XML配置，而且是很 多XML配 置。  Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML 配置。  Spring 3.0引入 了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。\n\n所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切  换，所以编 写配置挤占了编写应用程序逻辑的时间。和所有框架一样， Spring实用，但与此同时它要求 的回报也不少。\n\n除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标， 而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题 就会严重阻碍项目的开发进度\n\n\n\n### 1.2.2 SpringBoot解决上述spring问题\n\nSpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在 配置与逻辑 业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的 效率，一定程度上缩短 了项目周期\n\n**起步依赖**\n起步依赖本质上是一个Maven项目对象模型(Project Object Model，POM) ，定义了对其他库的传递依 赖，这些东西加在一起即支持某项功能。\n简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\n\n**自动配置**\nspringboot的自动配置，指的是springboot ，会自动将一些配置类的bean注册进ioc容器，我们可以需 要的地方使用@autowired或者@resource等注解来使用它。\n“自动”的表现形式就是我们只需要引我们想用功能的包，相关的配置我们完全不用管， springboot会自 动注入这些配置bean ，我们直接使用这些bean即可\nspringboot: 简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率\n\n\n\n## 1.3 SpringBoot 案例实现                                                               \n\n> 案例需求：请求Controller中的方法，并将返回值响应到页面\n\n**（ 1 ）使用Spring Initializr方式构建Spring Boot项目**\n本质上说， Spring Initializr是一个Web应用，它提供了一个基本的项目结构，能够帮助我们快速 构建一个基础的Spring Boot项目\n\n![image-20211226122458831](http://img.itzhameng.com/blog/image-20211226122458831.png?imageslim)\n\nProjectSDK”用于设置创建项目使用的JDK版本，这里，使用之前初始化设置好的JDK版本即可；\n在“Choose Initializr Service URL （选择初始化服务地址） ”下使用默认的初始化服务地址“https://start.spring.io”进行Spring Boot项目创建（注意使用快速方式创建Spring Boot项目时，所在主机须在联网状态下）\n\n![image-20211226122811626](http://img.itzhameng.com/blog/image-20211226122811626.png?imageslim)\n\n![image-20211226123021028](http://img.itzhameng.com/blog/image-20211226123021028.png?imageslim)\n\n\n\nSpring Boot项目就创建好了。创建好的Spring Boot项目结构如图：\n\n![image-20211226123627968](http://img.itzhameng.com/blog/image-20211226123627968.png?imageslim)\n\n使用Spring Initializr方式构建的SpringBoot项目会默认生成项目启动类、存放前端静态资源和页 面的文件夹、编写项目配置的配置文件以及进行项目单元测试的测试类\n\n\n\n**（2） 创建一个用于Web访问的Controller**\n\n`com.hzit.springboot_demo`包下创建名称为`controller`的包，在该包下创建一个请求处理控制类`HelloController `， 并编写一个请求处理方法（注意：`SpringbootDemoApplication.java`主程序需要和`controller`包，处在同一层级）\n\n![image-20211226124251132](http://img.itzhameng.com/blog/image-20211226124251132.png?imageslim)\n\n\n\n**`HelloController`具体内容如下：**\n\n``` java\n@RestController // 该注解为组合注解，等同于Spring中@Controller+@ResponseBody注解\npublic class HelloController {\n    @RequestMapping(\"/hello\")\n    public String demo() {\n        return \"你好 spring Boot\";\n    }\n}\n```\n\n\n\n**(3) 运行项目**\n运行主程序启动类SpringbootDemoApplication ，项目启动成功后，在控制台上会发现Spring Boot项目默认启动的端口号为8080 ，此时，可以在浏览器上访问“http://localhost:8080/hello”\n\n![image-20211226124505902](http://img.itzhameng.com/blog/image-20211226124505902.png?imageslim)\n\n\n\n项目运行结果：页面输出的内容是“你好Spring Boot”，至此，构建Spring Boot项目就完成了\n\n![image-20211226124632465](http://img.itzhameng.com/blog/image-20211226124632465.png?imageslim)\n\n附：如果出现乱码，尝试一下解决方案\n\n> 方案一：\n>\n> ``` java\n> @RequestMapping(produces = \"application/json; charset=utf-8\")\n> ```\n>\n> 方案二：\n>\n> ``` properties\n> #设置响应为utf-8\n> spring.http.encoding.force-response=true\n> ```\n\n\n\n## 1.4 单元测试与热部署\n\n###  1.4.1 单元测试\n\n开发中，每当完成一个功能接口或业务方法的编写后，通常都会借助单元测试验证该功能是否正  确。  Spring Boot对项目的单元测试提供了很好的支持，在使用时，需要提前在项目的pom.xml文件中添加`spring-boot-starter-test`测试依赖启动器，可以通过相关注解实现单元测试\n演示：\n**1 ．添加spring-boot-starter-test测试依赖启动器**\n在项目的pom.xml文件中添加spring-boot-starter-test测试依赖启动器，示例代码如下 ：\n\n``` xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-test</artifactId>\n    <scope>test</scope>\n</dependency>\n```\n\n注意：使用Spring Initializr方式搭建的Spring Boot项目，会自动加入spring-boot-starter-test测试依赖 启动器，无需再手动添加\n\n**2 ．编写单元测试类和测试方法**\n使用Spring Initializr方式搭建的Spring Boot项目，会在src.test.java测试目录下自动创建与项目主程序 启动类对应的单元测试类\n\n``` java\n@RunWith(SpringRunner.class)\n// 测试启动器，并加载Spring Boot测试注解\n@SpringBootTest\n// 标记为Spring Boot单元测试类，并加载项目的ApplicationContext上下文环境\nclass SpringbootDemoApplicationTests {\n\n    @Autowired\n    private HelloController demoController;\n\n    // 自动创建的单元测试方法实例\n    @Test\n    void contextLoads() {\n        String demo = demoController.demo();\n        System.out.println(demo);\n    }\n\n}\n```\n\n上述代码中，先使用@Autowired注解注入了HelloController实例对象，然后在contextLoads() 方法中调用了HelloController类中对应的请求控制方法demo() ，并输出打印结果\n\n![image-20211226125420592](http://img.itzhameng.com/blog/image-20211226125420592.png?imageslim)\n\n\n\n### 1.4.2 热部署(可选)\n\n在开发过程中，通常会对一段业务代码不断地修改测试，在修改之后往往需要重启服务，有些服 务需要加载很久才能启动成功，这种不必要的重复操作极大的降低了程序开发效率。为此，SpringBoot框架专门提供了进行热部署的依赖启动器，用于进行项目热部署。\n<mark>无需手动重启项目，但是修改以后项目还是会自动重启项目</mark>\n演示：\n**1.添加spring-boot-devtools热部署依赖启动器**\n在Spring Boot项目进行热部署测试之前，需要先在项目的pom.xml文件中添加spring-boot-devtools热\n部署依赖启动器:\n\n``` xml\n<!-- 引入热部署依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n</dependency>\n```\n\n由于使用的是IDEA开发工具，添加热部署依赖后可能没有任何效果，接下来还需要针对IDEA开发 工具进行热部署相关的功能设置\n\n**2.IDEA工具热部署设置**\n选择IDEA工具界面的【File】->【Settings】选项，打开Compiler面板设置页面\n\n![image-20211226125909928](http://img.itzhameng.com/blog/image-20211226125909928.png?imageslim)\n\n选择Build下的Compiler选项，在右侧勾选“Build project automatically”选项将项目设置为自动编 译，单击【Apply】→【OK】按钮保存设置\n\n在项目任意页面中使用组合快捷键`Ctrl+Shift+Alt+/`打开Maintenance选项框，选中并打开 Registry页面，具体如图1-17所示\n\n![image-20211226130032724](http://img.itzhameng.com/blog/image-20211226130032724.png?imageslim)\n\n列表中找到`compiler.automake.allow.when.app.running` ，将该选项后的Value值勾选，用于指 定IDEA工具在程序运行过程中自动编译，最后单击【Close】按钮完成设置\n\n\n\n**3 ．热部署效果测试**\n\n页面原始输出的内容是“你好 spring Boot”。\n\n为了测试配置的热部署是否有效，接下来，在不关闭当前项目的情况下，将HelloController类中的请 求处理方法demo()的返回值修改为“你好 spring Boot，你好 Java”并保存，查看控制台信息会发现项目能够自动构 建和编译，说明项目热部署生效\n\n![image-20211226130522544](http://img.itzhameng.com/blog/image-20211226130522544.png?imageslim)\n\n可以看出，浏览器输出了“你好 spring Boot，你好 Java” ，说明项目热部署配置成功\n\n![image-20211226130533170](http://img.itzhameng.com/blog/image-20211226130533170.png?imageslim)\n\n## 1.5 全局配置文件\n\n官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties\n\n全局配置文件能够对一些默认配置值进行修改。  Spring Boot使用一个application.properties或者 application.yaml的文件作为全局配置文件，该文件存放在src/main/resource目录或者类路径 的/conﬁg ，一般会选择resource目录。接下来，将针对这两种全局配置文件进行讲解 ：\n\n### 1.5.1 application.properties配置文件                                                               \n\n使用Spring Initializr方式构建Spring Boot项目时，会在resource目录下自动生成一个空的 `application.properties`文件,\nSpring Boot项目启动时会自动加载application.properties文件。\n我们可以在application.properties文件中定义SpringBoot项目的相关属性，当然，这些相关属性可以 是系统属性、环境变量、命令参数等信息，也可以是自定义配置文件名称和位置\n\n``` properties\nserver.port=8081\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nserver.servlet.context-path=/boot\n```\n\n接下来，通过一个案例对Spring Boot项目中application.properties配置文件的具体使用进行讲解 演示：\n预先准备了两个实体类文件，后续会演示将application.properties配置文件中的自定义配置属性注入 到Person实体类的对应属性中\n\n**（ 1 ）先在项目的`com.hzit.springboot_demo`包下创建一个pojo包，并在该包下创建两个实体类Pet和Person**\n\n``` java\npublic class Pet {\n    private String type;\n    private String name;\n    \n    // 省略属性getXX()和setXX()方法\n    // 省略toString()方法\n}\n```\n\n``` java\n@Component   //用于将Person类作为Bean注入到Spring容器中\n@ConfigurationProperties(prefix = \"person\") //将配置文件中以person开头的属性注入到该 类中\npublic class Person {\n\n    private int id; //id\n    private String name;//名称\n    private List hobby; //爱好\n\n    private String[] family; //家庭成员\n    private Map map;\n    private Pet pet;    //宠物\n\n    // 省略属性getXX()和setXX()方法\n    // 省略toString()方法\n}\n```\n\n@ConﬁgurationProperties(preﬁx = \"person\")注解的作用是将配置文件中以<font color='red'>person开头</font>的属性值通过 setXX()注入到实体类对应属性中\n@Component注解的作用是将当前注入属性值的Person类对象作为Bean组件放到Spring容器中，只有 这样才能被@ConﬁgurationProperties注解进行赋值\n\n**（ 2）打开项目的resources目录下的application.properties配置文件，在该配置文件中编写需要对 Person类设置的配置属性**\n\n``` properties\nperson.id=1001\nperson.name=翠花\nperson.hobby=吃饭,睡觉,打豆豆\nperson.family=张大毛,王老五\nperson.map.k1=v1\nperson.map.k2=v2\nperson.pet.type=dog\nperson.pet.name=来福\n```\n\n编写application.properties配置文件时，由于要配置的Person对象属性是我们自定义的， Spring Boot无法自动识别，所以不会有任何书写提示。在实际开发中，为了出现代码提示的效果来方便配置， 在使用@ConﬁgurationProperties注解进行配置文件属性值注入时，可以在pom.xml文件中添加一个  Spring Boot提供的配置处理器依赖:\n\n``` xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n在pom.xml中添加上述配置依赖后，还需要重新运行项目启动类或者使用“Ctrl+F9”快捷键（即Build Project）重构当前Spring Boot项目方可生效\n\n**（ 3 ）查看application.properties配置文件是否正确**\n\n同时查看属性配置效果，打开通过IDEA工具创建 的项目测试类，在该测试类中引入Person实体类Bean ，并进行输出测试\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class PropertiesTests {\n\n    @Autowired\n    private Person person;\n\n    @Test\n    public void test(){\n        System.out.println(\"person = \" + person);\n    }\n}\n```\n\n打印结果：\n\n![image-20211226135642436](http://img.itzhameng.com/blog/image-20211226135642436.png?imageslim)\n\n可以看出，测试方法test()运行成功，同时正确打印出了Person实体类对象。至此，说明 application.properties配置文件属性配置正确，并通过相关注解自动完成了属性注入\n\n\n\n### 1.5.2 application.yaml配置文件\n\n> YAML(YAML Ain't a Markup Language)不是一种标记语言的外语缩写  ；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。--百度百科\n\nYAML文件格式是Spring Boot支持的一种JSON超集文件格式，相较于传统的Properties配置文件，YAML文件以数据为核心，是一种更为直观且容易被电脑识别的数据序列化格式。  application.yaml配置 文件的工作原理和application.properties是一样的，只不过yaml格式配置文件看起来更简洁一些。\n\n- YAML文件的扩展名可以使用**.yml**或者**.yaml**。\n- application.yml文件使用 “key: （空格） value”格式配置属性，使用缩进控制层级关系。 \n\n这里，针对不同数据类型的属性值，介绍一下YAML\n**（ 1）value值为普通数据类型（例如数字、字符串、布尔等）**\n当YAML配置文件中配置的属性值为普通数据类型时，可以直接配置对应的属性值，同时对于字符 串类型的属性值，不需要额外添加引号，示例代码如下\n\n``` yaml\nserver:\n  port: 8001\n  servlet:\n    context-path: /hello\n```\n\n上述代码用于配置server的port和servlet属性属于一个级别，以上配置等价于properties文件中：\n\n``` properties\nserver.port=8001\nserver.servlet.context-path=/hello\n```\n\n\n\n**（ 2）value值为数组和单列集合**\n\n当YAML配置文件中配置的属性值为数组或单列集合类型时，主要有两种书写方式：**缩进式写法**和**行内式**写法。\n\n其中，缩进式写法还有两种表示形式，示例代码如下\n\n``` yaml\nperson:\n  hobby:\n    - play\n    - read\n    - sleep\n```\n\n或者\n\n``` yaml\nperson:\n  hobby:\n    play,\n    read,\n    sleep\n```\n\n上述代码中，在YAML配置文件中通过两种缩进式写法对person对象的单列集合（或数组）类型的爱好 hobby赋值为play、 read和sleep。其中一种形式为“- （空格）属性值” ，另一种形式为多个属性值之后 加英文逗号分隔（注意，最后一个属性值后不要加逗号）。\n\n``` yaml\nperson:\n  hobby: [play,read,sleep]\n```\n\n通过上述示例对比发现， YAML配置文件的行内式写法更加简明、方便。另外，包含属性值的中括 号“[]”还可以进一步省略，在进行属性赋值时，程序会自动匹配和校对\n\n\n\n**（ 3）value值为Map集合和对象**\n当YAML配置文件中配置的属性值为Map集合或对象类型时， YAML配置文件格式同样可以分为两种书写 方式：缩进式写法和行内式写法。其中，缩进式写法的示例代码如下\n\n``` yaml\nperson:\n  map:\n    k1: v1\n    k2: v2\n```\n\n对应的行内式写法示例代码如下\n\n``` yaml\nperson:\n  map: {k1: v1,k2: v2}\n```\n\n在YAML配置文件中，配置的属性值为Map集合或对象类型时，缩进式写法的形式按照YAML文件格式编\n写即可，而行内式写法的属性值要用大括号“{}”包含。\n\n\n\n接下来，在Properties配置文件演示案例基础上，通过配置application.yaml配置文件对Person对象进 行赋值，具体使用如下\n（ 1 ）在项目的resources目录下，新建一个application.yaml配置文件，在该配置文件中编写为Person\n类设置的配置属性\n\n``` yaml\nperson:\n  id: 1002\n  name: 张无忌\n  hobby: [吃饭，睡觉，打豆豆]\n  family: [赵敏,周芷若]\n  map: {k1: v1,k2: v2}\n  pet: {type: dog,name: 旺财}\n```\n\n![image-20211226141600420](http://img.itzhameng.com/blog/image-20211226141600420.png?imageslim)\n\n可以看出，测试方法conﬁgurationTest()同样运行成功，并正确打印出了Person实体类对象。\n需要说明的是，本次使用application.yaml配置文件进行测试时需要提前将application.properties配置 文件中编写的配置注释，这是因为<mark>application.properties配置文件会覆盖application.yaml配置文件</mark>\n\n\n\n## 1.6 配置文件属性值的注入                                                              \n\n使用Spring Boot全局配置文件设置属性时：\n如果配置属性是Spring Boot已有属性，例如服务端口server.port ，那么Spring Boot内部会自动扫描并 读取这些配置文件中的属性值并覆盖默认属性。\n如果配置的属性是用户自定义属性，例如刚刚自定义的Person实体类属性，还必须在程序中注入这些配 置属性方可生效。\nSpring Boot支持多种注入配置文件属性的方式，下面来介绍如何使用注解@ConﬁgurationProperties 和@Value注入属性\n\n### 1.6.1 @ConﬁgurationProperties注入属性\n\nSpring Boot提供的@ConﬁgurationProperties注解用来快速、方便地将配置文件中的自定义属性值批 量注入到某个Bean对象的多个对应属性中。假设现在有一个配置文件，如果使用@ConﬁgurationProperties注入配置文件的属性，示例代码如下：\n\n``` java\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n    private int id;\n    // 属性的setXX()方法\n    public void setId(int id) {\n        this.id = id;\n    }\n}\n```\n\n上述代码使用@Component和@ConﬁgurationProperties(preﬁx = “person”)将配置文件中的每个属性 映射到person类组件中。\n需要注意的是，使用@ConﬁgurationProperties\n\n\n\n### 1.6.2 使用@Value注入属性\n\n@Value注解是Spring框架提供的，用来读取配置文件中的属性值并逐个注入到Bean对象的对应属性  中， Spring Boot框架从Spring框架中对@Value注解进行了默认继承，所以在Spring Boot框架中还可 以使用该注解读取和注入配置文件属性值。使用@Value注入属性的示例代码如下\n\n``` java\n@Component\npublic class Person {\n    @Value(\"${person.id}\")\n    private int id;\n}\n```\n\n上述代码中，使用@Component和@Value注入Person实体类的id属性。其中， @Value不仅可以将配置文件的属性注入Person的id属性，还可以直接给id属性赋值，这点是@ConﬁgurationProperties 不支持的\n\n**演示@Value注解读取并注入配置文件属性的使用:**\n\n**（ 1 ）在com.hzit.springboot_demo.pojo包下新创建一个实体类Student ，并使用@Value注解注入属性**\n\n``` java\n@Component\npublic class Student {\n    @Value(\"${person.id}\")\n    private int id;\n    @Value(\"${person.name}\")\n    private String name; //名称\n\n    //省略toString\n}\n```\n\nStudent类使用@Value注解将配置文件的属性值读取和注入。\n从上述示例代码可以看出，使用@Value注解方式需要对每一个属性注入设置，同时又免去了属性的setXX()方法\n\n**（ 2）再次打开测试类进行测试**\n\n``` java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class PropertiesTests {\n    @Autowired\n    public Student student;\n\n    @Test\n    public void test() {\n        System.out.println(\"student = \" + student);\n    }\n}\n```\n\n![image-20211226143002260](http://img.itzhameng.com/blog/image-20211226143002260.png?imageslim)\n\n可以看出，测试方法test()运行成功，同时正确打印出了Student实体类对象。需要说明的 是，本示例中只是使用@Value注解对实例中Student对象的普通类型属性进行了赋值演示\n\n而@Value   注解对于包含Map集合、对象以及YAML文件格式的行内式写法的配置文件的属性注入都不支持，如果  赋值会出现错误\n\n\n\n## 1.7 自定义配置                                                                                \n\nspring Boot免除了项目中大部分的手动配置，对于一些特定情况，我们可以通过修改全局配置文  件以适应具体生产环境，可以说，几乎所有的配置都可以写在application.peroperties文件中， Spring  Boot会自动加载全局配置文件从而免除我们手动加载的烦恼。\n但是，如果我们自定义配置文件， Spring Boot是无法识别这些配置文件的，此时就需要我们手动加载。接下来，将针对Spring Boot的自定义配   置文件及其加载方式进行讲解\n\n### 1.7.1 使用@PropertySource加载配置文件                                                          \n\n对于这种加载自定义配置文件的需求，可以使用@PropertySource注解结合@Conﬁguration注解  配置类的方式来实现。  @PropertySource注解用于指定自定义配置文件的具体位置和名称。同时，为了 保证Spring Boot能够扫描该注解，还需要类上添加@Conﬁguration注解将实体类作为自定义配置类。\n当然，如果需要将自定义配置文件中的属性值注入到对应类的属性中，可以使用\n@ConﬁgurationProperties或者@Value注解进行属性值注入\n演示：\n（ 1 ）打开Spring Boot项目的resources目录，在项目的类路径下新建一个test.properties自定义配 置文件，在该配置文件中编写需要设置的配置属性\n\n``` properties\n#对实体类对象MyProperties进行属性配置\ntest.id=110\ntest.name=test\n```\n\n（ 2）在`com.hzit.springboot_demo.pojo`包下新创建一个配置类MyProperties ，提供test.properties自定义配置文件中对应的属性，并根据@PropertySource注解的使用进行相关配置\n\n``` java\n@Configuration   // 自定义配置类\n@PropertySource(\"classpath:test.properties\")  // 指定自定义配置文件位置和名称\n@EnableConfigurationProperties(MyProperties.class) // 开启对应配置类的属性注入功 能\n@ConfigurationProperties(prefix = \"test\")     // 指定配置文件注入属性前缀\npublic class MyProperties {\n    private int id;\n    private String name;\n\n    // 省略属性getXX()和setXX()方法\n    // 省略toString()方法\n}\n```\n\n主要是一个自定义配置类，通过相关注解引入了自定义的配置文件，并完成了自定义属性值的注 入。示例中的几个注解，具体说明如下:\n\n- @Conﬁguration注解表示当前类是一个自定义配置类，并添加为Spring容器的组件，这里也可以使用传统的@Component注解；\n- @PropertySource(\"classpath:test.properties\")注解指定了自定义配置文件的位置和名称，此示例表示自定义配置文件为classpath类路径下的test.properties文件；\n- @ConﬁgurationProperties(preﬁx = \"test\")注解将上述自定义配置文件test.properties中以test开头的属性值注入到该配置类属性中。\t\n- 如果配置类上使用的是@Component注解而非@Conﬁguration注解，那么@EnableConﬁgurationProperties注解还可以省略\n\n\n\n（ 3 ）进行测试\n\n``` java\n@Autowired\nprivate MyProperties myProperties;\n@Test\npublic void myPropertiesTest() {\n    System.out.println(myProperties);\n}\n```\n\n![image-20211226152840959](http://img.itzhameng.com/blog/image-20211226152840959.png?imageslim)\n\n\n\n### 1.7.2 @Conﬁguration编写自定义配置类\n\n在Spring Boot框架中，推荐使用配置类的方式向容器中添加和配置组件\n在Spring Boot框架中，通常使用@Conﬁguration注解定义一个配置类， Spring Boot会自动扫描和识别 配置类，从而替换传统Spring框架中的XML配置文件。\n当定义一个配置类后，还需要在类中的方法上使用@Bean注解进行组件配置，将方法的返回对象注入到 Spring容器中，并且组件名称默认使用的是方法名，当然也可以使用@Bean注解的name或value属性    自定义组件的名称\n\n演示：\n（ 1 ）在项目下新建一个`com.hzit.springboot_demo.service`包，并在该包下新创建一个类MyService ，该类中不需要编写 任何代码\n\n``` java\npublic class MyService {\n}\n```\n\n创建了一个空的MyService类，而该类目前没有添加任何配置和注解，因此还无法正常被Spring Boot扫 描和识别\n\n（ 2） 在项目的`com.hzit.springboot_demo.config`包下，新建一个类MyConﬁg ，并使用@Conﬁguration注解将该类声 明一个配置类，内容如下：\n\n``` java\n@Configuration\npublic class MyConfig {\n    @Bean       // 将返回值对象作为组件添加到Spring容器中，该组件id默认为方法名\n    public MyService myService() {\n        return new MyService();\n    }\n}\n```\n\nMyConﬁg是@Conﬁguration注解声明的配置类（类似于声明了一个XML配置文件），该配置类会\n\n被Spring Boot自动扫描识别；使用@Bean注解的myService()方法，其返回值对象会作为组件添加到了 Spring容器中（类似于XML配置文件中的标签配置），并且该组件的id默认是方法名myService\n\n（ 3 ）测试类\n\n``` java\n@Autowired\nprivate ApplicationContext applicationContext;\n\n@Test\npublic void iocTest() {\n    MyService myService = applicationContext.getBean(MyService.class);\n    System.out.println(\"myService = \" + myService);\n    System.out.println(applicationContext.containsBean(\"myService\"));\n}\n```\n\n上述代码中，先通过@Autowired注解引入了Spring容器实例ApplicationContext ，然后在测试方法 iocTest()中测试查看该容器中是否包括id为myService的组件。\n\n执行测试方法iocTest() ，查看控制台输出效果，结果如下：\n\n![image-20211226153911377](http://img.itzhameng.com/blog/image-20211226153911377.png?imageslim)\n\n从测试结果可以看出，测试方法iocTest()运行成功，显示运行结果为true ，表示Spirng的IOC容器中也 已经包含了id为myService的实例对象组件，说明使用自定义配置类的形式完成了向Spring容器进行组 件的添加和配置\n\n\n\n## 1.8 随机数设置及参数间引用                         \n\n在Spring Boot配置文件中设置属性时，除了可以像前面示例中显示的配置属性值外，还可以使用 **随机值**和参数间引用对属性值进行设置。下面，针对配置文件中这两种属性值的设置方式进行讲解\n\n### 1.8.1随机值设置           \n\n在Spring Boot配置文件中，随机值设置使用到了Spring Boot内嵌的` RandomValuePropertySource`类，对一些隐秘属性值或者测试用例属性值进行随机值注入\n随机值设置的语法格式为${random.xx}，xx表示需要指定生成的随机数类型和范围，它可以生成\n随机的整数、  uuid或字符串，示例代码如下\n\n``` properties\n#配置随机值\nmy.secret=${random.value}\n\n# 配置随机整数\nmy.number=${random.int}\n\n# 配置随机long类型数\nmy.bignumber=${random.long}\n\n# 配置随机uuid类型数\nmy.uuid=${random.uuid}\n\n# 配置小于10的随机整数\nmy.number.less.than.ten=${random.int(10)}\n\n# 配置范围在[1024,65536]之间的随机整数 \nmy.number.in.range=${random.int[1024,65536]}\n```\n\n上述代码中，使用RandomValuePropertySource类中random提供的随机数类型，分别展示了不 同类型随机值的设置示例\n\n\n\n### 1.8.2参数间引用\n\n在Spring Boot配置文件中，配置文件的属性值还可以进行参数间的引用，也就是在后一个配置的 属性值中直接引用先前已经定义过的属性，这样可以直接解析其中的属性值了。\n使用参数间引用的好处就是，在多个具有相互关联的配置属性中，只需要对其中一处属性预先配置，其 他地方都可以引用，省去了后续多处修改的麻烦\n参数间引用的语法格式为${xx}，xx表示先前在配置文件中已经配置过的属性名，示例代码如下\n\n``` properties\napp.name=MyApp\napp.description=${app.name} is a Spring Boot application\n```\n\n上述参数间引用设置示例中，先设置了“app.name=MyApp” ，将app.name属性的属性值设置为了 MyApp ；接着，在app.description属性配置中，使用${app.name}对前一个属性值进行了引用\n接下来，通过一个案例来演示使用随机值设置以及参数间引用的方式进行属性设置的具体使用和 效果，具体步骤如下\n（ 1 ）打开Spring Boot项目resources目录下的application.properties配置文件，在该配置文件中 分别通过随机值设置和参数间引用来配置两个测试属性，示例代码如下\n\n``` properties\n# 随机值设置以及参数间引用配置\ntom.age=${random.int[10,20]}\ntom.description=tom的年龄可能是${tom.age}\n```\n\n在上述application.properties配置文件中，先使用随机值设置了tom.age属性的属性值，该属性 值设置在了[10,20]之间，随后使用参数间引用配置了tom.description属性\n\n（ 2）打开\\项目的测试类，在该测试类中新增字符串类型的description属性，并将配置文件中的 tom.description属性进行注入，然后新增一个测试方法进行输出测试，示例代码如下\n\n``` java\n@Value(\"${tom.description}\")\nprivate String description;\n\n@Test\npublic void placeholderTest() {\n    System.out.println(description);\n}\n```\n\n上述代码中，通过@Value(\"${tom.description}\")注解将配置文件中的tom.description属性值注入到了 对应的description属性中，在测试方法placeholderTest()中对该属性值进行了输出打印。\n\n执行测试方法placeholderTest() ，查看控制台输出效果\n\n![image-20211226155755564](http://img.itzhameng.com/blog/image-20211226155755564.png?imageslim)\n\n可以看出，测试方法placeholderTest()运行成功，并打印出了属性description的注入内容，该内  容与配置文件中配置的属性值保持一致。接着，重复执行测试方法placeholderTest() ，查看控制台输出 语句中显示的年龄就会在[10,20]之间随机显示\n\n\n\n"},{"title":"Maven配置流程","url":"/post/0.html","content":"\n介绍Maven的安装和配置\n<!-- more -->\n# Maven\n\n## maven安装和配置\n\n### 1.解压maven压缩包\n\n### 2.配置环境变量\n\n![image-20230625101908478](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251019652.png)\n\n![image-20230625101940744](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251019821.png)\n\n![image-20230625102252222](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251022350.png)\n\n![image-20230625102257751](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251022872.png)\n\n![image-20230625102401258](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251024347.png)\n\n![image-20230625102535200](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251025277.png)\n\n### 3.配置本地仓库\n\n![image-20230625102638665](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251026751.png)\n\n![image-20230625102953003](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251029053.png)\n\n![image-20230625103007555](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251030665.png)\n\n![image-20230625105654795](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251056899.png)\n\n## 在idea里面配置Maven：\n\n![image-20230625111006587](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251110730.png)\n\n![image-20230625111709243](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251117346.png)\n\n## 用idea创建java项目：\n\n![image-20230625113507993](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251135102.png)\n\n![image-20230625113727021](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251137101.png)\n\n## maven导入依赖\n\n### 1.在 pom.xml 中编写 <dependencies> 标签\n\n![image-20230625141728227](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251417330.png)\n\n### 2.在 <dependencies> 标签中使用 <dependency> 引入坐标定义坐标的 groupId，artifactId，version\n\n![image-20230625141804897](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251418957.png)\n\n### 3.点击刷新按钮，使坐标生效\n\n![image-20230625141835394](https://trok-typora-img.oss-cn-guangzhou.aliyuncs.com/img/202306251418485.png)","tags":["Mave"]},{"title":"demon","url":"/post/ae0842e5.html","content":"\n这是摘要\n<!-- more -->\n\n# 标题1\n## 标题2\n### 标题3\n#### 标题4\n##### 标题5\n\n**这里是加粗**\n\n*这里是斜体*\n\n~~这是横线~~\n\n*无序列表1\n*无序列表2\n\n1. 有序列表1\n2. 有序列表2\n\n`内嵌代码`\n\n```\n代码块\n```\n\n> 引用"}]